'use strict';

var require$$0$3 = require('joi');
var require$$0 = require('lodash.merge');
var require$$1 = require('lodash.random');
var require$$2 = require('lodash.samplesize');
var require$$1$1 = require('selectn');
var require$$0$2 = require('mustache');
var require$$0$1 = require('geolib');
var require$$0$7 = require('url');
var require$$1$3 = require('events');
var require$$0$4 = require('debug');
var require$$0$5 = require('axios');
var require$$2$1 = require('https');
var require$$0$6 = require('lodash.clonedeep');
var require$$2$2 = require('home-assistant-js-websocket');
var require$$1$2 = require('ws');
var require$$0$8 = require('lowdb/adapters/FileAsync');
var require$$1$4 = require('lowdb');
var require$$2$3 = require('lodash');
var require$$1$5 = require('timestring');
var require$$0$9 = require('time-ago');
var require$$0$a = require('slugify');
var require$$1$6 = require('cron');
var require$$0$b = require('bonjour');
var require$$1$7 = require('flat');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$0__default$7 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
var require$$1__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$2__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$2$2);
var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
var require$$0__default$8 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
var require$$1__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$1$4);
var require$$2__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$2$3);
var require$$1__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$1$5);
var require$$0__default$9 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);
var require$$0__default$a = /*#__PURE__*/_interopDefaultLegacy(require$$0$a);
var require$$1__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$1$6);
var require$$0__default$b = /*#__PURE__*/_interopDefaultLegacy(require$$0$b);
var require$$1__default$7 = /*#__PURE__*/_interopDefaultLegacy(require$$1$7);

const merge$4 = require$$0__default['default'];
const random = require$$1__default['default'];
const sampleSize = require$$2__default['default'];
const selectn$c = require$$1__default$1['default'];

const DEFAULT_NODE_OPTIONS$3 = {
    config: {
        debugenabled: {},
        name: {},
        server: { isNode: true },
        version: (nodeDef) => nodeDef.version || 0,
    },
    input: {
        topic: { messageProp: 'topic' },
        payload: { messageProp: 'payload' },
    },
};

class BaseNode$7 {
    constructor({ node, config, RED, status, nodeOptions = {} }) {
        this.node = node;
        this.RED = RED;
        this.options = merge$4({}, DEFAULT_NODE_OPTIONS$3, nodeOptions);
        this._eventHandlers = _eventHandlers;
        this._internals = _internals;
        this._enabled = true;
        this.status = status;

        this.nodeConfig = Object.entries(this.options.config).reduce(
            (acc, [key, value]) => {
                if (value.isNode) {
                    acc[key] = this.RED.nodes.getNode(config[key]);
                } else if (typeof value === 'function') {
                    acc[key] = value.call(this, config);
                } else {
                    acc[key] = config[key];
                }

                return acc;
            },
            {}
        );

        node.on('input', this._eventHandlers.preOnInput.bind(this));
        node.on('close', this._eventHandlers.preOnClose.bind(this));

        const name = selectn$c('nodeConfig.name', this);
        this.node.debug(`instantiated node, name: ${name || 'undefined'}`);
    }

    get server() {
        return selectn$c('nodeConfig.server.controller', this);
    }

    get homeAssistant() {
        return selectn$c('server.homeAssistant', this);
    }

    get isConnected() {
        return this.homeAssistant && this.homeAssistant.isConnected;
    }

    get isHomeAssistantRunning() {
        return this.isConnected && this.homeAssistant.isHomeAssistantRunning;
    }

    get isIntegrationLoaded() {
        return this.isConnected && this.homeAssistant.isIntegrationLoaded;
    }

    get isEnabled() {
        return this._enabled;
    }

    set isEnabled(value) {
        this._enabled = !!value;
        this.status.setNodeState(this._enabled);
    }

    // Subclasses should override these as hooks into common events
    onClose(removed) {
        this.status.destroy();
    }

    onInput() {}

    send() {
        this.node.send(...arguments);
    }

    sendSplit(message, data, send) {
        if (!send) {
            send = this.send;
        }

        delete message._msgid;
        message.parts = {
            id: this.RED.util.generateId(),
            type: 'array',
            count: data.length,
            len: 1,
        };

        let pos = 0;
        for (let i = 0; i < data.length; i++) {
            message.payload = data.slice(pos, pos + 1)[0];
            message.parts.index = i;
            pos += 1;
            send(this.RED.util.cloneMessage(message));
        }
    }

    // Hack to get around the fact that node-red only sends warn / error to the debug tab
    debugToClient(debugMsg) {
        if (!this.nodeConfig.debugenabled) return;
        for (const msg of arguments) {
            const debugMsgObj = {
                id: this.node.id,
                name: this.node.name || '',
                msg,
            };
            this.RED.comms.publish('debug', debugMsgObj);
        }
    }

    getCastValue(datatype, value) {
        if (!datatype) return value;

        switch (datatype) {
            case 'num':
                return parseFloat(value);
            case 'str':
                return value + '';
            case 'bool':
                return !!value;
            case 'habool': {
                const booleanConfig = selectn$c(
                    'nodeConfig.server.config.ha_boolean',
                    this
                );
                const regex =
                    booleanConfig === undefined
                        ? `^(y|yes|true|on|home|open)$`
                        : `^(${booleanConfig})$`;
                return new RegExp(regex, 'i').test(value);
            }
            case 're':
                return new RegExp(value);
            case 'list':
                return value ? value.split(',').map((e) => e.trim()) : [];
            default:
                return value;
        }
    }

    castState(entity, type) {
        if (entity) {
            entity.original_state = entity.state;
            entity.state = this.getCastValue(type, entity.state);
        }
    }

    getContextValue(location, property, message) {
        if (message && location === 'msg') {
            return this.RED.util.getMessageProperty(message, property);
        }

        const contextKey = this.RED.util.parseContextStore(property);
        return this.node
            .context()
            [location].get(contextKey.key, contextKey.store);
    }

    setContextValue(val, location, property, message) {
        const contextKey = this.RED.util.parseContextStore(property);

        switch (location) {
            case 'none':
                break;
            case 'flow':
            case 'global':
                this.node
                    .context()
                    [location].set(contextKey.key, val, contextKey.store);
                break;
            case 'msg':
            default:
                this.RED.util.setObjectProperty(message, contextKey.key, val);
                break;
        }
    }

    getComparatorResult(
        comparatorType,
        comparatorValue,
        actualValue,
        comparatorValueDatatype,
        { message, entity, prevEntity }
    ) {
        if (comparatorValueDatatype === 'bool') {
            comparatorValue = comparatorValue === 'true';
        }

        let cValue;
        if (['msg', 'flow', 'global'].includes(comparatorValueDatatype)) {
            cValue = this.getContextValue(
                comparatorValueDatatype,
                comparatorValue,
                message
            );
        } else if (['entity', 'prevEntity'].includes(comparatorValueDatatype)) {
            cValue = selectn$c(
                comparatorValue,
                comparatorValueDatatype === 'entity' ? entity : prevEntity
            );
        } else if (
            comparatorType !== 'jsonata' &&
            comparatorValueDatatype === 'jsonata' &&
            comparatorValue
        ) {
            try {
                cValue = this.evaluateJSONata(comparatorValue, {
                    message,
                    entity,
                    prevEntity,
                });
            } catch (e) {
                throw new Error(`JSONata Error: ${e.message}`);
            }
        } else {
            if (
                comparatorType === 'includes' ||
                comparatorType === 'does_not_include'
            ) {
                comparatorValueDatatype = 'list';
            }

            cValue = this.getCastValue(
                comparatorValueDatatype,
                comparatorValue
            );
        }

        switch (comparatorType) {
            case 'is':
            case 'is_not': {
                // Datatype might be num, bool, str, re (regular expression)
                const isMatch =
                    comparatorValueDatatype === 're'
                        ? cValue.test(actualValue)
                        : cValue === actualValue;
                return comparatorType === 'is' ? isMatch : !isMatch;
            }
            case 'includes':
            case 'does_not_include': {
                const isIncluded = cValue.includes(actualValue);
                return comparatorType === 'includes' ? isIncluded : !isIncluded;
            }
            case 'cont':
                return (actualValue + '').indexOf(cValue) !== -1;
            case 'greater_than': // here for backwards compatibility
            case '>':
            case 'gt':
                return actualValue > cValue;
            case '>=':
            case 'gte':
                return actualValue >= cValue;
            case 'less_than': // here for backwards compatibility
            case '<':
            case 'lt':
                return actualValue < cValue;
            case '<=':
            case 'lte':
                return actualValue <= cValue;
            case 'starts_with':
                return actualValue.startsWith(cValue);
            case 'in_group': {
                const ent = this.homeAssistant.getStates(cValue);
                const groupEntities =
                    selectn$c('attributes.entity_id', ent) || [];
                return groupEntities.includes(actualValue);
            }
            case 'jsonata':
                if (!cValue) return true;

                try {
                    return (
                        this.evaluateJSONata(cValue, {
                            message,
                            entity,
                            prevEntity,
                        }) === true
                    );
                } catch (e) {
                    throw new Error(`JSONata Error: ${e.message}`);
                }
        }
    }

    evaluateJSONata(expression, objs = {}) {
        const expr = this.RED.util.prepareJSONataExpression(
            expression,
            this.node
        );
        const { entity, message, prevEntity } = objs;

        expr.assign('entity', () => entity);
        expr.assign(
            'entities',
            (val) => this.homeAssistant && this.homeAssistant.getStates(val)
        );
        expr.assign('outputData', (obj) => {
            if (!obj) {
                const filtered = Object.keys(objs).reduce((acc, key) => {
                    // ignore message as it already accessable
                    if (key !== 'message' && objs[key] !== undefined) {
                        acc[key] = objs[key];
                    }
                    return acc;
                }, {});
                return filtered;
            }

            return objs[obj];
        });
        expr.assign('prevEntity', () => prevEntity);
        expr.assign('randomNumber', random);
        expr.assign('sampleSize', sampleSize);

        return this.RED.util.evaluateJSONataExpression(expr, message);
    }

    getTypedInputValue(value, valueType, props = {}) {
        let val;
        switch (valueType) {
            case 'msg':
            case 'flow':
            case 'global':
                val = this.getContextValue(valueType, value, props.message);
                break;
            case 'bool':
                val = value === 'true';
                break;
            case 'json':
                try {
                    val = JSON.parse(value);
                } catch (e) {
                    // error parsing
                }
                break;
            case 'date':
                val = Date.now();
                break;
            case 'jsonata':
                // no reason to error just return undefined
                if (value === '') {
                    val = undefined;
                    break;
                }
                try {
                    val = this.evaluateJSONata(value, {
                        data: props.data,
                        entity: props.entity,
                        entityId: props.entityId,
                        eventData: props.eventData,
                        message: props.message,
                        prevEntity: props.prevEntity,
                        results: props.results,
                    });
                } catch (e) {
                    throw new Error(`JSONata Error: ${e.message}`);
                }
                break;
            case 'num':
                val = Number(value);
                break;
            case 'none':
                val = undefined;
                break;
            case 'config': {
                const config = {
                    ...this.nodeConfig,
                    server: this.nodeConfig.server.id,
                };
                val = value.length ? selectn$c(value, config) : config;
                break;
            }
            case 'data':
            case 'entity':
            case 'entityState':
            case 'eventData':
            case 'headers':
            case 'params':
            case 'triggerId':
            case 'prevEntity':
            case 'results':
                val = props[valueType];
                break;
            default:
                val = value;
        }
        return val;
    }

    setCustomOutputs(properties = [], message, extras) {
        properties.forEach((item) => {
            const value = this.getTypedInputValue(item.value, item.valueType, {
                message,
                ...extras,
            });

            try {
                this.setContextValue(
                    value,
                    item.propertyType,
                    item.property,
                    message
                );
            } catch (e) {
                this.node.warn(
                    `Custom Ouput Error (${item.propertyType}:${item.property}): ${e.message}`
                );
            }
        });
    }
}

const _internals = {
    parseInputMessage(inputOptions, msg) {
        if (!inputOptions) return;
        const parsedResult = {};

        for (const [fieldKey, fieldConfig] of Object.entries(inputOptions)) {
            // Find messageProp value if it's a string or Array
            // When it's an array lowest valid index takes precedent
            const messageProp = Array.isArray(fieldConfig.messageProp)
                ? fieldConfig.messageProp.reduce(
                      (val, cur) => val || selectn$c(cur, msg),
                      undefined
                  )
                : selectn$c(fieldConfig.messageProp, msg);

            // Try to load from message
            const result = {
                key: fieldKey,
                value: messageProp,
                source: 'message',
                validation: null,
            };

            // If message missing value and node has config that can be used instead
            if (result.value === undefined && fieldConfig.configProp) {
                result.value = selectn$c(fieldConfig.configProp, this.nodeConfig);
                result.source = 'config';
            }

            if (
                result.value === undefined &&
                fieldConfig.default !== undefined
            ) {
                result.value =
                    typeof fieldConfig.default === 'function'
                        ? fieldConfig.default.call(this)
                        : fieldConfig.default;
                result.source = 'default';
            }

            // If value not found in both config and message
            if (result.value === undefined) {
                result.source = 'missing';
            }

            // If validation for value is configured run validation, optionally throwing on failed validation
            if (fieldConfig.validation) {
                const { error, value } = fieldConfig.validation.schema.validate(
                    result.value,
                    {
                        convert: true,
                    }
                );
                if (error && fieldConfig.validation.haltOnFail) throw error;
                result.validation = {
                    error,
                    value,
                };
            }

            // Assign result to config key value
            parsedResult[fieldKey] = result;
        }

        return parsedResult;
    },
};

const _eventHandlers = {
    preOnInput(message, send, done) {
        try {
            const parsedMessage = _internals.parseInputMessage.call(
                this,
                this.options.input,
                message
            );

            this.onInput({
                parsedMessage,
                message,
                send,
                done,
            });
        } catch (e) {
            if (e && e.isJoi) {
                this.status.setFailed('Error');
                done(e.message);
                return;
            }

            throw e;
        }
    },

    async preOnClose(removed, done) {
        this.node.debug(
            `closing node. Reason: ${
                removed ? 'node deleted' : 'node re-deployed'
            }`
        );
        try {
            await this.onClose(removed);
            done();
        } catch (e) {
            this.node.error(e.message);
        }
    },
};

var BaseNode_1 = BaseNode$7;

const geolib = require$$0__default$1['default'];
const selectn$b = require$$1__default$1['default'];

function shouldInclude$1(targetString, includeRegex, excludeRegex) {
    if (!targetString || (!includeRegex && !excludeRegex)) {
        return true;
    }

    // If include regex isn't passed then include everything since test will be skipped
    // otherwise default to false and set in regex test
    let shouldIncludeTest = !includeRegex;
    let shouldExcludeTest = false;

    if (includeRegex && includeRegex.test(targetString)) {
        shouldIncludeTest = true;
    }
    if (excludeRegex && excludeRegex.test(targetString)) {
        shouldExcludeTest = true;
    }

    return shouldIncludeTest && !shouldExcludeTest;
}

function shouldIncludeEvent$3(eventId, filter, filterType) {
    if (!filter) return true;

    if (filterType === 'substring') {
        const found = filter
            .split(',')
            .map((f) => f.trim())
            .filter((filterStr) => eventId.indexOf(filterStr) >= 0);
        return found.length > 0;
    }

    if (filterType === 'regex') {
        return new RegExp(filter).test(eventId);
    }

    return filter === eventId;
}

function toCamelCase$3(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, (match, index) => {
        if (+match === 0) return '';
        return index === 0 ? match.toLowerCase() : match.toUpperCase();
    });
}

function inZone$1(location, zone) {
    const { radius, ...zoneLatLog } = zone;
    const inZone = geolib.isPointWithinRadius(location, zoneLatLog, radius);

    return inZone;
}

function getLocationData$1(entity) {
    const coord = {
        latitude: entity.attributes.latitude,
        longitude: entity.attributes.longitude,
    };

    return geolib.isValidCoordinate(coord) ? coord : false;
}

function getZoneData$1(zone) {
    const data = getLocationData$1(zone);
    if (data === false || selectn$b('attributes.radius', zone) === undefined)
        return false;

    data.radius = zone.attributes.radius;

    return data;
}

function getWaitStatusText$2(timeout, timeoutUnits) {
    const timeoutMs = getTimeInMilliseconds$3(timeout, timeoutUnits);
    switch (timeoutUnits) {
        case 'milliseconds':
            return `waiting for ${timeout} milliseconds`;
        case 'hours':
        case 'days':
            return `waiting until ${timeoutStatus(timeoutMs)}`;
        case 'minutes':
        default:
            return `waiting for ${timeout} ${timeoutUnits}: ${timeoutStatus(
                timeoutMs
            )}`;
    }
}

function getTimeInMilliseconds$3(value, valueUnits) {
    switch (valueUnits) {
        case 'milliseconds':
            return value;
        case 'minutes':
            return value * 60000;
        case 'hours':
            return value * 3.6e6;
        case 'days':
            return value * 8.64e7;
        default:
            return value * 1000;
    }
}

function timeoutStatus(milliseconds = 0) {
    const timeout = Date.now() + milliseconds;
    const timeoutStr = new Date(timeout).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        hour12: false,
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
    });

    return timeoutStr;
}

function isValidDate$1(val) {
    const d = new Date(val);
    return d instanceof Date && !isNaN(d);
}

function parseTime$1(time) {
    const regex = /^(0?\d|1\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/;
    const matches = time.match(regex);

    if (!matches) return matches;

    const [, hour, minutes, seconds = 0] = matches;

    return {
        hour: Number(hour),
        minutes: Number(minutes),
        seconds: Number(seconds),
    };
}

function getEntitiesFromJsonata$1(jsonata) {
    const regex = /\$entities\("([a-z_]+\.[a-z0-9_]+)"\)/g;
    const matches = jsonata.matchAll(regex);

    return new Set(Array.from(matches, (m) => m[1]));
}

var utils = {
    shouldInclude: shouldInclude$1,
    shouldIncludeEvent: shouldIncludeEvent$3,
    toCamelCase: toCamelCase$3,
    inZone: inZone$1,
    getLocationData: getLocationData$1,
    getZoneData: getZoneData$1,
    getWaitStatusText: getWaitStatusText$2,
    getTimeInMilliseconds: getTimeInMilliseconds$3,
    isValidDate: isValidDate$1,
    parseTime: parseTime$1,
    getEntitiesFromJsonata: getEntitiesFromJsonata$1,
};

/*
 * Modified from https://github.com/node-red/node-red/blob/master/nodes/core/core/80-template.js
 */

const mustache = require$$0__default$2['default'];
const selectn$a = require$$1__default$1['default'];

const { toCamelCase: toCamelCase$2 } = utils;

function parseContext(key) {
    const match = /^(flow|global)(\[(\w+)\])?\.(.+)/.exec(key);
    if (match) {
        const parts = {};
        parts.type = match[1];
        parts.store = match[3] === '' ? 'default' : match[3];
        parts.field = match[4];
        return parts;
    }
    return undefined;
}

/**
 * Custom Mustache Context capable to collect message property and node
 * flow and global context
 */

function NodeContext(msg, parent, nodeContext, serverName) {
    this.msgContext = new mustache.Context(msg, parent);
    this.nodeContext = nodeContext;
    this.serverName = serverName;
}

NodeContext.prototype = new mustache.Context();

NodeContext.prototype.lookup = function (name) {
    // try message first:
    const value = this.msgContext.lookup(name);
    if (value !== undefined) {
        return value;
    }

    // try flow/global context:
    const context = parseContext(name);
    if (context) {
        const type = context.type;
        const store = context.store;
        const field = context.field;
        const target = this.nodeContext[type];
        if (target) {
            try {
                return target.get(field, store);
            } catch (err) {}
        }
    }

    // try state entities
    // version 0.10.3 changed from states.domain.entity to entity.d.e
    const match = /^(?:states|entity)\.(\w+\.\w+)(?:\.(.+))?/.exec(name);
    if (match) {
        const gHomeAssistant = this.nodeContext.global.get('homeassistant');
        const states = gHomeAssistant[this.serverName].states;
        const entityId = match[1];
        const path = match[2] || 'state';

        return selectn$a(path, states[entityId]) || '';
    }

    return '';
};

NodeContext.prototype.push = function push(view) {
    return new NodeContext(
        view,
        this.nodeContext,
        this.msgContext,
        this.serverName
    );
};

function RenderTemplate$9(data, message, context, serverName, altTags = false) {
    const template = data || '';

    if (
        (altTags !== true && template.indexOf('{{') !== -1) ||
        (altTags === true && template.indexOf('<%') !== -1)
    ) {
        return mustache.render(
            data,
            new NodeContext(message, null, context, toCamelCase$2(serverName)),
            null,
            altTags === true ? ['<%', '%>'] : null
        );
    }

    return data;
}

var mustacheContext = RenderTemplate$9;

const Joi$7 = require$$0__default$3['default'];

const BaseNode$6 = BaseNode_1;
const RenderTemplate$8 = mustacheContext;

const nodeOptions$j = {
    config: {
        name: {},
        server: { isNode: true },
        protocol: {},
        method: {},
        path: {},
        data: {},
        dataType: (nodeDef) => nodeDef.dataType || 'json',
        responseType: {},
        outputProperties: {},
    },
    input: {
        protocol: {
            messageProp: 'payload.protocol',
            configProp: 'protocol',
            default: 'websocket',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string()
                    .valid('websocket', 'http')
                    .label('protocol'),
            },
        },
        method: {
            messageProp: 'payload.method',
            configProp: 'method',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string().valid('get', 'post').label('method'),
            },
        },
        path: {
            messageProp: 'payload.path',
            configProp: 'path',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string().allow('').label('path'),
            },
        },
        data: {
            messageProp: 'payload.data',
            configProp: 'data',
        },
        dataType: {
            messageProp: 'payload.dataType',
            configProp: 'dataType',
            default: 'json',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string().valid('json', 'jsonata').label('dataType'),
            },
        },
        location: {
            messageProp: 'payload.location',
            configProp: 'location',
            default: 'payload',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string().label('location'),
            },
        },
        locationType: {
            messageProp: 'payload.locationType',
            configProp: 'locationType',
            default: 'msg',
            validation: {
                haltOnFail: true,
                schema: Joi$7.string()
                    .valid('msg', 'flow', 'global', 'none')
                    .label('locationType'),
            },
        },
        responseType: {
            messageProp: 'payload.responseType',
            configProp: 'responseType',
            default: 'json',
            validation: {
                schema: Joi$7.string()
                    .valid('json', 'text', 'arraybuffer')
                    .label('responseType'),
            },
        },
        outputProperties: {
            messageProp: 'payload.outputProperties',
            configProp: 'outputProperties',
        },
    },
};

class Api$1 extends BaseNode$6 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$j });
    }

    async onInput({ message, parsedMessage, send, done }) {
        const node = this.node;
        const config = this.nodeConfig;

        if (!this.isConnected) {
            this.status.setFailed('No Connection');
            done('API call attempted without connection to server.');

            return;
        }

        let data;
        if (parsedMessage.dataType.value === 'jsonata') {
            try {
                data = JSON.stringify(
                    this.evaluateJSONata(parsedMessage.data.value, { message })
                );
            } catch (e) {
                this.status.setFailed('Error');
                done(e.message);
                return;
            }
        } else {
            data = RenderTemplate$8(
                typeof parsedMessage.data.value === 'object'
                    ? JSON.stringify(parsedMessage.data.value)
                    : parsedMessage.data.value,
                message,
                node.context(),
                config.server.name
            );
        }

        const method = parsedMessage.method.value;
        let apiCall;

        if (parsedMessage.protocol.value === 'http') {
            const path = RenderTemplate$8(
                parsedMessage.path.value,
                message,
                node.context(),
                config.server.name
            ).replace(/^\/(?:api\/)?/, '');

            if (!path) {
                done('HTTP request requires a valid path.');
                this.status.setFailed();
                return;
            }

            this.debugToClient({ method, path, data });

            apiCall = this.homeAssistant[method].bind(
                this.homeAssistant,
                path,
                data,
                parsedMessage.responseType.value
            );
        } else {
            try {
                const json = JSON.parse(data);

                if (!json.type) {
                    done(
                        `A WebSocket request requires a 'type' property in the data object.`
                    );
                    this.status.setFailed();
                    return;
                }

                this.debugToClient(json);

                apiCall = this.homeAssistant.send.bind(
                    this.homeAssistant,
                    json
                );
            } catch (e) {
                done(e.message);
                this.status.setFailed();
                return;
            }
        }

        this.status.setSending();

        const results = await apiCall().catch((err) => {
            done(
                'API Error. ' + err.message
                    ? `Error Message: ${err.message}`
                    : ''
            );
            this.status.setFailed('API Error');
        });

        try {
            this.setCustomOutputs(
                parsedMessage.outputProperties.value,
                message,
                {
                    results,
                    config: this.nodeConfig,
                }
            );
        } catch (e) {
            this.status.setFailed('error');
            done(e.message);
            return;
        }

        this.status.setSuccess(`${parsedMessage.protocol.value} called`);

        send(message);
        done();
    }
}

var Api_1 = Api$1;

var _const = Object.freeze({
    ENTITY_SWITCH: 'switch',
    ENTITY_DEVICE_TRIGGER: 'device_trigger',
    HA_CLIENT_READY: 'ha_client:ready',
    HA_EVENT_DEVICE_REGISTRY_UPDATED: 'devices_updated',
    HA_EVENT_INTEGRATION: 'nodered',
    HA_EVENT_STATE_CHANGED: 'state_changed',
    HA_EVENT_TAG_SCANNED: 'tag_scanned',
    HA_EVENTS: 'ha_events',
    INTEGRATION_EVENT: 'integration',
    INTEGRATION_LOADED: 'loaded',
    INTEGRATION_NOT_LOADED: 'notloaded',
    INTEGRATION_UNLOADED: 'unloaded',
    STATE_CONNECTING: 0,
    STATE_CONNECTED: 1,
    STATE_DISCONNECTED: 2,
    STATE_ERROR: 3,
    TYPEDINPUT_MSG: 'msg',
    TYPEDINPUT_FLOW: 'flow',
    TYPEDINPUT_GLOBAL: 'global',
    TYPEDINPUT_DATE: 'date',
    TYPEDINPUT_BOOL: 'bool',
    TYPEDINPUT_ENV: 'env',
    TYPEDINPUT_JSON: 'json',
    TYPEDINPUT_JSONATA: 'jsonata',
    TYPEDINPUT_NONE: 'none',
    TYPEDINPUT_NUM: 'num',
    TYPEDINPUT_STR: 'str',
    ZONE_ENTER: 'enter',
    ZONE_ENTER_OR_LEAVE: 'enter_leave',
    ZONE_LEAVE: 'leave',
});

const merge$3 = require$$0__default['default'];

const BaseNode$5 = BaseNode_1;
const {
    INTEGRATION_EVENT: INTEGRATION_EVENT$1,
    INTEGRATION_LOADED: INTEGRATION_LOADED$1,
    INTEGRATION_UNLOADED: INTEGRATION_UNLOADED$4,
    INTEGRATION_NOT_LOADED: INTEGRATION_NOT_LOADED$3,
} = _const;

const DEFAULT_NODE_OPTIONS$2 = {
    debug: false,
    config: {
        exposeToHomeAssistant: (nodeDef) =>
            nodeDef.exposeToHomeAssistant === undefined
                ? false
                : nodeDef.exposeToHomeAssistant,
    },
};

class EventsNode$4 extends BaseNode$5 {
    constructor({ node, config, RED, status, nodeOptions = {} }) {
        nodeOptions = merge$3({}, DEFAULT_NODE_OPTIONS$2, nodeOptions);
        super({ node, config, RED, status, nodeOptions });
        this.listeners = {};
        this.registered = false;
        this.integrationErrorMessage =
            'Node-RED custom integration needs to be installed in Home Assistant for this node to function correctly.';
        this.status = status;
        this.status.init({
            nodeState: this.isEnabled,
            homeAssistant: this.homeAssistant,
        });

        // Setup event listeners
        const events = {
            'ha_client:close': this.onHaEventsClose,
            'ha_client:error': this.onHaEventsError,
            [INTEGRATION_EVENT$1]: this.onHaIntegration,
        };
        Object.entries(events).forEach(([event, callback]) =>
            this.addEventClientListener(event, callback.bind(this))
        );
    }

    addEventClientListener(event, handler) {
        if (this.homeAssistant) {
            this.listeners[event] = handler;
            this.homeAssistant.addListener(event, handler);
        }
    }

    removeEventClientListeners() {
        if (this.homeAssistant) {
            Object.entries(this.listeners).forEach(([event, handler]) => {
                this.homeAssistant.removeListener(event, handler);
            });
        }
    }

    async onClose(removed) {
        super.onClose(removed);
        this.removeEventClientListeners();
    }

    onHaEventsClose() {
        this.registered = false;
    }

    onHaEventsError(err) {
        if (err && err.message) this.node.error(err.message);
    }

    onHaIntegration(type) {
        switch (type) {
            case INTEGRATION_LOADED$1:
                this.registerEntity();
                break;
            case INTEGRATION_UNLOADED$4:
            case INTEGRATION_NOT_LOADED$3:
                this.registered = false;
                break;
        }
    }

    registerEntity() {
        if (this.nodeConfig.exposeToHomeAssistant === false) {
            return false;
        }

        if (!this.isIntegrationLoaded) {
            if (
                this.node.type === 'ha-webhook' ||
                this.node.type === 'ha-entity'
            ) {
                this.node.error(this.integrationErrorMessage);
                this.status.setFailed('Error');
            }
            return false;
        }

        if (this.registered) {
            return false;
        }
    }
}

var EventsNode_1 = EventsNode$4;

/* eslint-disable camelcase */

const selectn$9 = require$$1__default$1['default'];

const EventsNode$3 = EventsNode_1;
const RenderTemplate$7 = mustacheContext;
const { HA_CLIENT_READY } = _const;

const domainsNeedingArrays = [
    'homeassistant',
    'input_datetime',
    'input_number',
];
const QUEUE_NONE = 'none';
const QUEUE_FIRST = 'first';
const QUEUE_ALL = 'all';
const QUEUE_LAST = 'last';

const nodeOptions$i = {
    debug: true,
    config: {
        service_domain: {},
        service: {},
        entityId: {},
        data: {},
        dataType: (nodeDef) => nodeDef.dataType || 'json',
        mergecontext: {},
        name: {},
        server: { isNode: true },
        mustacheAltTags: {},
        outputProperties: {},
        queue: {},
    },
};

class CallService$1 extends EventsNode$3 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$i });

        if (this.nodeConfig.queue !== QUEUE_NONE) {
            this.queue = [];
            this.addEventClientListener(
                HA_CLIENT_READY,
                this.onClientReady.bind(this)
            );
        }
    }

    isObjectLike(v) {
        return v !== null && typeof v === 'object';
    }

    tryToObject(v) {
        if (!v) return null;
        try {
            return JSON.parse(v);
        } catch (e) {
            return v;
        }
    }

    onInput({ message, parsedMessage, send, done }) {
        const config = this.nodeConfig;
        if (!this.isConnected && config.queue === QUEUE_NONE) {
            this.status.setFailed('No Connection');
            done('Call-Service attempted without connection to server.');

            return;
        }

        let payload, payloadDomain, payloadService;

        if (message && message.payload) {
            payload = this.tryToObject(message.payload);
            payloadDomain = selectn$9('domain', payload);
            payloadService = selectn$9('service', payload);
        }
        const configDomain = config.service_domain;
        const configService = config.service;
        const context = this.node.context();
        const apiDomain = RenderTemplate$7(
            payloadDomain || configDomain,
            message,
            context,
            config.server.name
        );
        const apiService = RenderTemplate$7(
            payloadService || configService,
            message,
            context,
            config.server.name
        );
        let configData;
        if (config.dataType === 'jsonata' && config.data) {
            try {
                configData = JSON.stringify(
                    this.evaluateJSONata(config.data, { message })
                );
            } catch (e) {
                this.status.setFailed('Error');
                done(e.message);
                return;
            }
        } else {
            configData = RenderTemplate$7(
                config.data,
                message,
                context,
                config.server.name,
                config.mustacheAltTags
            );
        }

        const apiData = this.getApiData(payload, configData);

        if (!apiDomain || !apiService) {
            done(
                `call service node is missing api "${
                    !apiDomain ? 'domain' : 'service'
                }" property, not found in config or payload`
            );
            this.status.setFailed('Error');
            return;
        }

        this.node.debug(
            `Calling Service: ${apiDomain}:${apiService} -- ${JSON.stringify(
                apiData || {}
            )}`
        );

        // Merge entity id field into data property if it doesn't exist
        if (
            config.entityId &&
            !Object.prototype.hasOwnProperty.call(apiData, 'entity_id')
        ) {
            const entityId = RenderTemplate$7(
                config.entityId,
                message,
                context,
                config.server.name,
                config.mustacheAltTags
            );
            // homeassistant domain requires entity_id to be an array for multiple ids
            if (
                domainsNeedingArrays.includes(apiDomain) &&
                entityId.indexOf(',') !== -1
            ) {
                apiData.entity_id = entityId.split(',').map((e) => e.trim());
            } else {
                apiData.entity_id = entityId;
            }
        }

        const obj = {
            apiDomain,
            apiService,
            apiData,
            message,
            done,
            send,
        };

        if (!this.isConnected) {
            switch (this.nodeConfig.queue) {
                case QUEUE_FIRST:
                    if (this.queue.length === 0) {
                        this.queue = [obj];
                    }
                    break;
                case QUEUE_ALL:
                    this.queue.push(obj);
                    break;
                case QUEUE_LAST:
                    this.queue = [obj];
                    break;
            }
            this.status.setText(`${this.queue.length} queued`);
            return;
        }

        this.processInput(obj);
    }

    onClientReady() {
        while (this.queue.length) {
            this.processInput(this.queue.pop());
        }
    }

    getApiData(payload, data) {
        let contextData = {};

        let payloadData = selectn$9('data', payload);
        let configData = this.tryToObject(data);
        payloadData = payloadData || {};
        configData = configData || {};

        // Calculate payload to send end priority ends up being 'Config, Global Ctx, Flow Ctx, Payload' with right most winning
        if (this.nodeConfig.mergecontext) {
            const ctx = this.node.context();
            let flowVal = ctx.flow.get(this.nodeConfig.mergecontext);
            let globalVal = ctx.global.get(this.nodeConfig.mergecontext);
            flowVal = flowVal || {};
            globalVal = globalVal || {};
            contextData = { ...globalVal, ...flowVal };
        }

        return { ...configData, ...contextData, ...payloadData };
    }

    async processInput({
        apiDomain,
        apiService,
        apiData,
        message,
        done,
        send,
    }) {
        this.status.setSending();

        this.debugToClient({
            domain: apiDomain,
            service: apiService,
            data: apiData,
        });

        try {
            await this.homeAssistant.callService(
                apiDomain,
                apiService,
                apiData
            );
        } catch (err) {
            // ignore 'connection lost' error on homeassistant.restart
            if (
                apiDomain !== 'homeassistant' &&
                apiService !== 'restart' &&
                selectn$9('error.code', err) !== 3
            ) {
                done(`Call-service error. ${err.message ? err.message : ''}`);
                this.status.setFailed('API Error');
                return;
            }
        }

        this.status.setSuccess(`${apiDomain}.${apiService} called`);
        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                data: {
                    domain: apiDomain,
                    service: apiService,
                    data: apiData || null,
                },
            });
        } catch (e) {
            this.status.setFailed('error');
            done(e.message);
            return;
        }

        send(message);
        done();
    }
}

var CallService_1 = CallService$1;

const selectn$8 = require$$1__default$1['default'];

const { HA_EVENT_DEVICE_REGISTRY_UPDATED: HA_EVENT_DEVICE_REGISTRY_UPDATED$1 } = _const;

class Comms$1 {
    constructor(RED, homeAssistant, serverId) {
        this.RED = RED;
        this.homeAssistant = homeAssistant;
        this.serverId = serverId;

        this.startListeners();
    }

    startListeners() {
        // Setup event listeners
        const events = {
            'ha_client:services_loaded': this.onServicesLoaded,
            'ha_client:states_loaded': this.onStatesLoaded,
            'ha_events:state_changed': this.onStateChanged,
            integration: this.onIntegrationEvent,
            [HA_EVENT_DEVICE_REGISTRY_UPDATED$1]: this.onDevicesUpdated,
        };
        Object.entries(events).forEach(([event, callback]) =>
            this.homeAssistant.addListener(event, callback.bind(this))
        );
    }

    publish(type, data, retain = true) {
        this.RED.comms.publish(
            `homeassistant/${type}/${this.serverId}`,
            data,
            retain
        );
    }

    onDevicesUpdated(devices) {
        this.publish('devices', devices);
    }

    onIntegrationEvent(eventType) {
        this.publish('integration', {
            event: eventType,
            version: this.homeAssistant.integrationVersion,
        });
    }

    onServicesLoaded(services) {}

    onStateChanged(event) {
        const entity = selectn$8('event.new_state', event);
        if (entity) {
            this.publish('entity', entity);
        }
    }

    onStatesLoaded(entities) {
        this.publish('entities', entities);
    }
}

var Comms_1 = Comms$1;

const debug$3 = require$$0__default$4['default']('home-assistant');
const selectn$7 = require$$1__default$1['default'];

const { STATE_CONNECTED: STATE_CONNECTED$2 } = _const;

const websocketMethods = [
    'callService',
    'connect',
    'getDevices',
    'getDeviceActions',
    'getDeviceActionCapabilities',
    'getDeviceTriggers',
    'getDeviceTriggerCapabilities',
    'getServices',
    'getStates',
    'getTranslations',
    'getUser',
    'send',
    'subscribeMessage',
];
const httpMethods = [
    'fireEvent',
    'get',
    'getHistory',
    'post',
    'renderTemplate',
];

class HomeAssistant$1 {
    constructor({ websocketAPI, httpAPI, eventBus }) {
        debug$3('Instantiating HomeAssistant');
        this.eventBus = eventBus;
        this.http = httpAPI;
        this.websocket = websocketAPI;
        this.eventsList = {};

        this.exposeMethods(this.websocket, websocketMethods);
        this.exposeMethods(this.http, httpMethods);
    }

    get isConnected() {
        return this.websocket.connectionState === STATE_CONNECTED$2;
    }

    get isHomeAssistantRunning() {
        return this.isConnected && this.websocket.isHomeAssistantRunning;
    }

    get integrationVersion() {
        return this.websocket.integrationVersion;
    }

    get isIntegrationLoaded() {
        return this.integrationVersion !== 0;
    }

    get connectionState() {
        return this.websocket.connectionState;
    }

    get version() {
        const client = selectn$7('weboscket.client', this);
        return client && client.haVersion;
    }

    exposeMethods(cls, methods) {
        methods.forEach((method) => {
            if (typeof cls[method] === 'function') {
                this[method] = cls[method].bind(cls);
            }
        });
    }

    getEntities() {
        const states = this.getStates();
        const entities = Object.keys(states).sort();

        return entities;
    }

    getTags() {
        return selectn$7('websocket.tags', this) || [];
    }

    async updateTags() {
        await this.websocket.updateTagList();
    }

    subscribeEvents() {
        return this.websocket.subscribeEvents(this.eventsList);
    }

    close() {
        const client = selectn$7('websocket.client', this);
        if (client) {
            client.close();
        }
    }

    addListener(event, handler, options = { once: false }) {
        if (options.once === true) {
            this.eventBus.once(event, handler);
        } else {
            this.eventBus.on(event, handler);
        }
    }

    removeListener(event, handler) {
        this.eventBus.removeListener(event, handler);
    }
}

var HomeAssistant_1 = HomeAssistant$1;

const axios = require$$0__default$5['default'];
const debug$2 = require$$0__default$4['default']('home-assistant:http');
const https = require$$2__default$1['default'];

const { shouldInclude } = utils;

class Http {
    constructor(config) {
        this.config = config;
        const apiOpts = { baseURL: `${config.baseUrl}/api` };
        apiOpts.headers = config.legacy
            ? config.apiPass
                ? { 'x-ha-access': config.apiPass }
                : {}
            : { Authorization: `Bearer ${config.apiPass}` };

        if (!config.rejectUnauthorizedCerts) {
            apiOpts.httpsAgent = new https.Agent({
                rejectUnauthorized: false,
            });
        }

        this.client = axios.create(apiOpts);
    }

    getHistory(
        timestamp,
        filterEntityId,
        endTimestamp,
        { include, exclude, flatten } = {}
    ) {
        let path = 'history/period';

        if (timestamp) {
            path = `${path}/${timestamp}`;
        }
        const params = {};
        if (filterEntityId) {
            params.filter_entity_id = filterEntityId;
        }
        if (endTimestamp) {
            params.end_time = endTimestamp;
        }

        // History returns an array for each entity_id and that array contains objects for each history item
        return this.get(path, params).then((result) => {
            if (!include && !exclude && !flatten) {
                return result;
            }

            // Filter out results by regex, include/exclude should already be an instance of RegEx
            if (include || exclude) {
                result = result.reduce((acc, entityArr) => {
                    const entityId =
                        entityArr && entityArr.length > 0
                            ? entityArr[0].entity_id
                            : null;

                    if (entityId && shouldInclude(entityId, include, exclude)) {
                        acc.push(entityArr);
                    }
                    return acc;
                }, []);
            }

            // Instead of returning the data from home assistant ( array for each entity_id ) return one flattened array
            // of one item per history entry
            if (flatten) {
                result = result
                    .reduce((acc, entityArray) => {
                        acc = acc.concat(entityArray);
                        return acc;
                    }, [])
                    .sort((a, b) => {
                        if (a.last_updated < b.last_updated) {
                            return -1;
                        }
                        if (a.last_updated > b.last_updated) {
                            return 1;
                        }
                        return 0;
                    });
            }

            return result;
        });
    }

    fireEvent(event, data) {
        return this.post(`events/${event}`, data);
    }

    renderTemplate(templateString) {
        return this.post('template', { template: templateString }, 'text');
    }

    async post(path, data = {}, responseType = 'json') {
        debug$2(`POST: ${this.config.baseUrl}/${path}`);

        this.client.defaults.responseType = responseType;

        return this.client
            .post(path, data)
            .then((res) => res.data || '')
            .catch((err) => {
                debug$2(`POST: request error: ${err.toString()}`);
                throw err;
            });
    }

    async get(path, params = {}, responseType = 'json') {
        debug$2(`GET: ${this.config.baseUrl}/${path}`);

        this.client.defaults.responseType = responseType;

        return this.client
            .request({ url: path, params: params })
            .then((res) => res.data || '')
            .catch((err) => {
                debug$2(`GET: request error: ${err.toString()}`);
                throw err;
            });
    }
}

var Http_1 = Http;

const debug$1 = require$$0__default$4['default']('home-assistant:socket');
const WebSocket = require$$1__default$2['default'];
const {
    ERR_INVALID_AUTH: ERR_INVALID_AUTH$1,
    MSG_TYPE_AUTH_INVALID,
    MSG_TYPE_AUTH_OK,
    MSG_TYPE_AUTH_REQUIRED,
} = require$$2__default$2['default'];

/*
 * Pretty much a copy from https://github.com/home-assistant/home-assistant-js-websocket
 */
function createSocket$1({
    auth,
    connectionDelay,
    eventBus,
    rejectUnauthorizedCerts,
    url,
}) {
    debug$1('[Auth Phase] Initializing', url);

    function connect(promResolve, promReject) {
        debug$1('[Auth Phase] New connection', url);
        eventBus.emit('ha_client:connecting');

        const socket = new WebSocket(url, {
            rejectUnauthorized: rejectUnauthorizedCerts,
        });

        // If invalid auth, we will not try to reconnect.
        let invalidAuth = false;

        const onOpen = async (event) => {
            try {
                socket.send(JSON.stringify(auth));
            } catch (err) {
                invalidAuth = err === ERR_INVALID_AUTH$1;
                socket.close();
            }
        };

        const onMessage = async (event) => {
            const message = JSON.parse(event.data);

            debug$1('[Auth Phase] Received', message);

            switch (message.type) {
                case MSG_TYPE_AUTH_INVALID:
                    invalidAuth = true;
                    socket.close();
                    break;

                case MSG_TYPE_AUTH_OK:
                    socket.removeEventListener('open', onOpen);
                    socket.removeEventListener('message', onMessage);
                    socket.removeEventListener('close', onClose);
                    socket.removeEventListener('error', onClose);
                    promResolve(socket);
                    break;

                default:
                    if (message.type !== MSG_TYPE_AUTH_REQUIRED) {
                        debug$1('[Auth Phase] Unhandled message', message);
                    }
            }
        };

        const onClose = () => {
            // If we are in error handler make sure close handler doesn't also fire.
            socket.removeEventListener('close', onClose);
            if (invalidAuth) {
                promReject(ERR_INVALID_AUTH$1);
                return;
            }

            // Try again in a second
            setTimeout(() => connect(promResolve, promReject), 5000);
        };

        socket.addEventListener('open', onOpen);
        socket.addEventListener('message', onMessage);
        socket.addEventListener('close', onClose);
        socket.addEventListener('error', onClose);
    }

    return new Promise((resolve, reject) => {
        // if hass.io, do a 5 second delay so it doesn't spam the hass.io proxy
        // https://github.com/zachowj/node-red-contrib-home-assistant-websocket/issues/76
        setTimeout(
            () => connect(resolve, reject),
            connectionDelay !== false ? 5000 : 0
        );
    });
}

var createSocket_1 = createSocket$1;

const { getCollection } = require$$2__default$2['default'];

function subscribeDeviceRegistry$1(conn, cb) {
    const fetchDeviceRegistry = (conn) =>
        conn.sendMessagePromise({
            type: 'config/device_registry/list',
        });

    const subscribeUpdates = (conn, store) =>
        conn.subscribeEvents(async () => {
            const devices = await fetchDeviceRegistry(conn);
            store.setState(devices, true);
        }, 'device_registry_updated');

    const collection = getCollection(
        conn,
        '_devices',
        fetchDeviceRegistry,
        subscribeUpdates
    );
    collection.subscribe(cb);
}

var collections = {
    subscribeDeviceRegistry: subscribeDeviceRegistry$1,
};

const cloneDeep$5 = require$$0__default$6['default'];
const debug = require$$0__default$4['default']('home-assistant:ws');
const selectn$6 = require$$1__default$1['default'];
const {
    callService: callService$2,
    createConnection,
    getUser,
    subscribeConfig,
    subscribeEntities,
    subscribeServices,
    ERR_CANNOT_CONNECT,
    ERR_CONNECTION_LOST,
    ERR_HASS_HOST_REQUIRED,
    ERR_INVALID_AUTH,
    ERR_INVALID_HTTPS_TO_HTTP,
} = require$$2__default$2['default'];

const createSocket = createSocket_1;
const {
    HA_EVENT_DEVICE_REGISTRY_UPDATED,
    HA_EVENT_INTEGRATION,
    HA_EVENT_STATE_CHANGED,
    HA_EVENTS,
    INTEGRATION_EVENT,
    INTEGRATION_NOT_LOADED: INTEGRATION_NOT_LOADED$2,
    INTEGRATION_LOADED,
    INTEGRATION_UNLOADED: INTEGRATION_UNLOADED$3,
    STATE_DISCONNECTED: STATE_DISCONNECTED$1,
    STATE_ERROR: STATE_ERROR$1,
    STATE_CONNECTED: STATE_CONNECTED$1,
    STATE_CONNECTING: STATE_CONNECTING$1,
    HA_EVENT_TAG_SCANNED,
} = _const;
const { subscribeDeviceRegistry } = collections;

class Websocket {
    constructor(config, eventBus) {
        this.eventBus = eventBus;
        this.config = config;
        this.connectionState = STATE_DISCONNECTED$1;
        this.states = {};
        this.services = {};
        this.devices = [];
        this.tags = null;
        this.statesLoaded = false;
        this.client = null;
        this.subscribedEvents = new Set();
        this.unsubCallback = {};
        this.integrationVersion = 0;
        this.isHomeAssistantRunning = false;

        this.eventBus.on(
            'ha_client:connecting',
            this.onClientConnecting.bind(this)
        );
        this.onStatesLoadedAndRunning('initial_connection_ready');
    }

    emitEvent(event, data) {
        return this.eventBus.emit(event, data);
    }

    async connect() {
        // Convert from http:// -> ws://, https:// -> wss://
        const url = `ws${this.config.baseUrl.substr(4)}/api/websocket`;

        const auth = {
            type: 'auth',
            [this.config.legacy ? 'api_password' : 'access_token']:
                this.config.apiPass,
        };

        this.client = await createConnection({
            createSocket: () =>
                createSocket({
                    auth,
                    connectionDelay: this.config.connectionDelay,
                    eventBus: this.eventBus,
                    rejectUnauthorizedCerts:
                        this.config.rejectUnauthorizedCerts,
                    url,
                }),
        }).catch((e) => {
            this.connectionState = STATE_ERROR$1;
            this.emitEvent('ha_client:error');
            // Handle connection errors
            switch (e) {
                case ERR_CANNOT_CONNECT:
                    throw new Error('Cannot connect to Home Assistant server');
                case ERR_INVALID_AUTH:
                    throw new Error(
                        'Invalid access token or password for websocket'
                    );
                case ERR_CONNECTION_LOST:
                    throw new Error('connection lost');
                case ERR_HASS_HOST_REQUIRED:
                    throw new Error('Base URL not set in server config');
                case ERR_INVALID_HTTPS_TO_HTTP:
                    throw new Error('ERR_INVALID_HTTPS_TO_HTTP');
            }
            throw e;
        });

        // Check if user has admin privileges
        await this.checkUserType();

        this.onClientOpen();
        // emit connected for only the first connection to the server
        // so we can setup certain things only once like registerEvents
        this.emitEvent('ha_client:connected');
        this.clientEvents();
        this.haEvents();
    }

    async checkUserType() {
        const user = await this.getUser();
        if (user.is_admin === false) {
            this.connectionState = STATE_ERROR$1;
            this.client.close();
            throw new Error(
                'User required to have admin privileges in Home Assistant'
            );
        }
    }

    getUser() {
        return getUser(this.client);
    }

    clientEvents() {
        // Client events
        const events = {
            ready: this.onClientOpen,
            disconnected: this.onClientClose,
            'reconnect-error': this.onClientError,
        };
        Object.entries(events).forEach(([event, callback]) =>
            this.client.addEventListener(event, callback.bind(this))
        );
    }

    async haEvents() {
        // Home Assistant Events
        await this.client.subscribeEvents(
            (evt) => this.integrationEvent(evt),
            HA_EVENT_INTEGRATION
        );
        subscribeConfig(this.client, (config) =>
            this.onClientConfigUpdate(config)
        );

        subscribeEntities(this.client, (ent) => this.onClientStates(ent));
        subscribeServices(this.client, (ent) => this.onClientServices(ent));
        subscribeDeviceRegistry(this.client, (devices) => {
            this.emitEvent(HA_EVENT_DEVICE_REGISTRY_UPDATED, devices);
            this.devices = devices;
        });
    }

    onHomeAssistantRunning() {
        if (!this.isHomeAssistantRunning) {
            this.isHomeAssistantRunning = true;
            this.emitEvent('ha_client:running');
            if (this.integrationVersion === 0) {
                this.createIntegrationEvent(INTEGRATION_NOT_LOADED$2);
            }
        }
    }

    integrationEvent(evt) {
        const oldVersion = this.integrationVersion;
        switch (evt.data.type) {
            case INTEGRATION_LOADED:
                this.integrationVersion = evt.data.version;
                break;
            case INTEGRATION_UNLOADED$3:
                this.integrationVersion = 0;
                break;
            case INTEGRATION_NOT_LOADED$2:
                this.emitEvent(INTEGRATION_EVENT, evt.data.type);
                return;
        }
        if (oldVersion !== this.integrationVersion) {
            this.emitEvent(INTEGRATION_EVENT, evt.data.type);
        }
    }

    async subscribeEvents(events) {
        const currentEvents = new Set(Object.values(events));

        // If events contains '__ALL__' register all events and skip individual ones
        if (currentEvents.has('__ALL__')) {
            if (this.subscribedEvents.has('__ALL__')) {
                // Nothing to do
                return;
            }

            this.subscribedEvents.forEach((e) => {
                if (e !== '__ALL__') {
                    this.unsubCallback[e]();
                    delete this.unsubCallback[e];
                    this.subscribedEvents.delete(e);
                }
            });

            // subscribe to all event and save unsubscribe callback
            this.unsubCallback.__ALL__ = await this.client.subscribeEvents(
                (ent) => this.onClientEvents(ent)
            );

            this.subscribedEvents.add('__ALL__');
            return;
        }

        // Always need the state_changed event
        currentEvents.add(HA_EVENT_STATE_CHANGED);
        currentEvents.add(HA_EVENT_TAG_SCANNED);

        const add = new Set(
            [...currentEvents].filter((x) => !this.subscribedEvents.has(x))
        );
        const remove = new Set(
            [...this.subscribedEvents].filter((x) => !currentEvents.has(x))
        );

        // Create new subscription list
        this.subscribedEvents = new Set([
            ...[...currentEvents].filter((x) => this.subscribedEvents.has(x)),
            ...add,
        ]);

        // Remove unused subscriptions
        remove.forEach((e) => {
            this.unsubCallback[e]();
            delete this.unsubCallback[e];
        });

        // Subscribe to each event type and save each unsubscribe callback
        for (const type of add) {
            this.unsubCallback[type] = await this.client.subscribeEvents(
                (ent) => this.onClientEvents(ent),
                type
            );
        }
    }

    subscribeMessage(callback, subscribeMessage, options) {
        return this.client.subscribeMessage(
            callback,
            subscribeMessage,
            options
        );
    }

    onClientStates(msg) {
        if (!msg || Object.keys(msg).length === 0) {
            return;
        }

        this.states = msg;

        if (!this.statesLoaded) {
            this.statesLoaded = true;
            this.emitEvent('ha_client:states_loaded', this.states);
        }
    }

    onClientServices(msg) {
        if (!msg || Object.keys(msg).length === 0) {
            return;
        }

        this.services = msg;

        if (!this.servicesLoaded) {
            this.servicesLoaded = true;
            this.emitEvent('ha_client:services_loaded', this.services);
        }
    }

    onStatesLoadedAndRunning(event = 'ready') {
        const statesLoaded = new Promise((resolve, reject) => {
            this.eventBus.once('ha_client:states_loaded', resolve);
        });
        const homeAssinstantRunning = new Promise((resolve, reject) => {
            this.eventBus.once('ha_client:running', resolve);
        });
        Promise.all([statesLoaded, homeAssinstantRunning]).then(([states]) => {
            this.eventBus.emit(`ha_client:${event}`, states);
        });
    }

    onClientEvents(msg) {
        if (!msg || !msg.data || msg.data === 'ping') {
            return;
        }

        const eventType = msg.event_type;
        const entityId = selectn$6('data.entity_id', msg);
        const event = {
            event_type: eventType,
            entity_id: entityId,
            event: msg.data,
            origin: msg.origin,
            time_fired: msg.time_fired,
            context: msg.context,
        };

        if (eventType === HA_EVENT_STATE_CHANGED) {
            const state = selectn$6('event.new_state', event);
            // Validate a minimum state_changed event
            if (state && entityId) {
                this.states[entityId] = state;
            } else {
                debug(
                    `Not processing ${HA_EVENT_STATE_CHANGED} event: ${JSON.stringify(
                        event
                    )}`
                );
                return;
            }
        }

        // Emit on the event type channel
        if (eventType) {
            this.emitEvent(`${HA_EVENTS}:${eventType}`, event);

            // Most specific emit for event_type and entity_id
            if (entityId) {
                this.emitEvent(`${HA_EVENTS}:${eventType}:${entityId}`, event);
            }
        }

        // Emit on all channel
        this.emitEvent(`${HA_EVENTS}:all`, event);
    }

    async onClientConfigUpdate(config) {
        if (
            config.components.includes('nodered') &&
            this.integrationVersion === 0
        ) {
            try {
                const version = await this.getIntegrationVersion();
                this.createIntegrationEvent(INTEGRATION_LOADED, version);
            } catch (e) {}
        }

        if (!this.tags && config.components.includes('tag')) {
            await this.updateTagList();
        }

        // Prior to HA 0.111.0 state didn't exist
        if (config.state === undefined || config.state === 'RUNNING') {
            this.onHomeAssistantRunning();
        }
    }

    async updateTagList() {
        try {
            this.tags = await this.send({
                type: 'tag/list',
            });
        } catch (e) {
            debug(`Error fetching tag list: ${e}`);
        }
    }

    getIntegrationVersion() {
        return this.send({
            type: 'nodered/version',
        });
    }

    createIntegrationEvent(type, version) {
        this.integrationEvent({
            data: { type, version },
        });
    }

    onClientOpen() {
        this.onStatesLoadedAndRunning();
        this.integrationVersion = 0;
        this.isHomeAssistantRunning = false;
        this.connectionState = STATE_CONNECTED$1;
        this.emitEvent('ha_client:open');
    }

    onClientClose() {
        this.integrationVersion = 0;
        this.isHomeAssistantRunning = false;
        this.connectionState = STATE_DISCONNECTED$1;
        this.emitEvent('ha_client:close');

        debug('events connection closed, cleaning up connection');
        this.resetClient();
    }

    onClientError(data) {
        debug('events connection error, cleaning up connection');
        debug(data);
        this.emitEvent('ha_client:error', data);
        this.resetClient();
    }

    onClientConnecting() {
        this.connectionState = STATE_CONNECTING$1;
    }

    resetClient() {
        this.servicesLoaded = false;
        this.statesLoaded = false;
        this.connectionState = STATE_DISCONNECTED$1;
        this.emitEvent('ha_client:close');
    }

    getDevices() {
        return this.devices;
    }

    getDeviceActions(deviceId) {
        if (!deviceId) return [];

        return this.client.sendMessagePromise({
            type: 'device_automation/action/list',
            device_id: deviceId,
        });
    }

    getDeviceActionCapabilities(action) {
        if (!action) return [];

        return this.client.sendMessagePromise({
            type: 'device_automation/action/capabilities',
            action,
        });
    }

    getDeviceTriggers(deviceId) {
        if (!deviceId) return [];

        return this.client.sendMessagePromise({
            type: 'device_automation/trigger/list',
            device_id: deviceId,
        });
    }

    getDeviceTriggerCapabilities(trigger) {
        if (!trigger) return [];

        return this.client.sendMessagePromise({
            type: 'device_automation/trigger/capabilities',
            trigger,
        });
    }

    getStates(entityId) {
        if (entityId) {
            return this.states[entityId]
                ? cloneDeep$5(this.states[entityId])
                : null;
        }

        return cloneDeep$5(this.states);
    }

    getServices() {
        return cloneDeep$5(this.services);
    }

    getTranslations(category, language) {
        if (!category) return [];

        return this.client.sendMessagePromise({
            type: 'frontend/get_translations',
            language,
            category,
        });
    }

    callService(domain, service, data) {
        debug(`Call-Service: ${domain}.${service} ${JSON.stringify(data)}`);
        return callService$2(this.client, domain, service, data);
    }

    send(data) {
        debug(`Send: ${JSON.stringify(data)}`);
        return this.client.sendMessagePromise(data);
    }
}

var Websocket_1 = Websocket;

const url = require$$0__default$7['default'];
const { EventEmitter } = require$$1__default$3['default'];

const HomeAssistant = HomeAssistant_1;
const HttpAPI = Http_1;
const WebsocketAPI = Websocket_1;

const SUPERVISOR_URL = 'http://supervisor/core';

function createHomeAssistantClient$1(config, credentials) {
    const creds = createCredentials(config, credentials);
    const httpConfig = createHttpConfig(config, creds);
    const websocketConfig = createWebsocketConfig(config, creds);
    const eventBus = new EventEmitter();
    eventBus.setMaxListeners(0);
    const httpAPI = new HttpAPI(httpConfig);
    const websocketAPI = new WebsocketAPI(websocketConfig, eventBus);

    return new HomeAssistant({ websocketAPI, httpAPI, eventBus });
}

function createCredentials(config, credentials) {
    let url;
    let apiPass = credentials.access_token;

    // For backwards compatibility prior to v0.0.4 when loading url and pass from flow.json
    if (config.url) {
        url = credentials.host || config.url;
        apiPass = credentials.access_token || config.pass;
    }

    // Check if using HA Add-on and import proxy token
    const addonBaseUrls = ['http://hassio/homeassistant', SUPERVISOR_URL];

    if (config.addon || addonBaseUrls.includes(credentials.host)) {
        url = SUPERVISOR_URL;
        apiPass = process.env.SUPERVISOR_TOKEN;
    } else {
        url = getBaseUrl(credentials.host);
    }

    return {
        url,
        apiPass,
    };
}

function createHttpConfig(
    config = { legacy: false, rejectUnauthorizedCerts: true },
    credentials
) {
    return {
        apiPass: credentials.apiPass,
        baseUrl: credentials.url,
        legacy: config.legacy,
        rejectUnauthorizedCerts: config.rejectUnauthorizedCerts,
    };
}

function createWebsocketConfig(
    config = { legacy: false, rejectUnauthorizedCerts: true },
    credentials
) {
    const connectionDelay =
        credentials.url !== SUPERVISOR_URL ? false : config.connectionDelay;

    return {
        apiPass: credentials.apiPass,
        baseUrl: credentials.url,
        legacy: config.legacy,
        rejectUnauthorizedCerts: config.rejectUnauthorizedCerts,
        connectionDelay,
    };
}

function getBaseUrl(url) {
    const errorMessage = validateBaseUrl(url);
    if (errorMessage) {
        throw new Error(errorMessage);
    }

    return url.trim();
}

function validateBaseUrl(baseUrl) {
    if (!baseUrl) {
        return 'config-server.errors.empty_base_url';
    }

    let parsedUrl;
    try {
        parsedUrl = new url.URL(baseUrl);
    } catch (e) {
        return 'config-server.errors.invalid_base_url';
    }

    if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
        return 'config-server.errors.invalid_protocol';
    }
}

var homeAssistant = { createHomeAssistantClient: createHomeAssistantClient$1 };

const merge$2 = require$$0__default['default'];

const Comms = Comms_1;
const { createHomeAssistantClient } = homeAssistant;
const { INTEGRATION_NOT_LOADED: INTEGRATION_NOT_LOADED$1 } = _const;
const { toCamelCase: toCamelCase$1 } = utils;

const nodeDefaults = {
    name: {},
    version: (nodeDef) => nodeDef.version || 0,
    legacy: {},
    addon: {},
    rejectUnauthorizedCerts: {},
    ha_boolean: {},
    connectionDelay: {},
    cacheJson: {},
};

class ConfigServer$1 {
    constructor({ node, config, RED }) {
        this.node = node;
        this.RED = RED;
        this.config = merge$2({}, nodeDefaults, config);
        this.exposedNodes = [];

        this.setOnContext('states', []);
        this.setOnContext('services', []);
        this.setOnContext('isConnected', false);

        node.on('close', this.onClose.bind(this));
    }

    async init() {
        try {
            this.homeAssistant = createHomeAssistantClient(
                this.config,
                this.node.credentials
            );

            this.startListeners();
            this.comms = new Comms(this.RED, this.homeAssistant, this.node.id);

            await this.homeAssistant.connect();
        } catch (e) {
            this.node.error(
                this.RED._(e.message, { base_url: this.node.credentials.host })
            );
        }
    }

    startListeners() {
        // Setup event listeners
        const events = {
            'ha_client:close': this.onHaEventsClose,
            'ha_client:open': this.onHaEventsOpen,
            'ha_client:connecting': this.onHaEventsConnecting,
            'ha_client:error': this.onHaEventsError,
            'ha_client:running': this.onHaEventsRunning,
            'ha_client:states_loaded': this.onHaStatesLoaded,
            'ha_client:services_loaded': this.onHaServicesLoaded,
            'ha_events:state_changed': this.onHaStateChanged,
            integration: this.onIntegrationEvent,
        };
        Object.entries(events).forEach(([event, callback]) =>
            this.homeAssistant.addListener(event, callback.bind(this))
        );
        this.homeAssistant.addListener(
            'ha_client:connected',
            this.registerEvents.bind(this),
            { once: true }
        );
    }

    get nameAsCamelcase() {
        return toCamelCase$1(this.config.name);
    }

    setOnContext(key, value) {
        let haCtx = this.node.context().global.get('homeassistant');
        haCtx = haCtx || {};
        haCtx[this.nameAsCamelcase] = haCtx[this.nameAsCamelcase] || {};
        haCtx[this.nameAsCamelcase][key] = value;
        this.node.context().global.set('homeassistant', haCtx);
    }

    getFromContext(key) {
        let haCtx = this.node.context().global.get('homeassistant');
        haCtx = haCtx || {};
        return haCtx[this.nameAsCamelcase]
            ? haCtx[this.nameAsCamelcase][key]
            : null;
    }

    onHaEventsOpen() {
        this.setOnContext('isConnected', true);

        this.node.log(`Connected to ${this.node.credentials.host}`);
    }

    onHaStateChanged(changedEntity) {
        const states = this.getFromContext('states');
        if (states) {
            states[changedEntity.entity_id] = changedEntity.event.new_state;
            this.setOnContext('states', states);
        }
    }

    onHaStatesLoaded(states) {
        this.setOnContext('states', states);
        this.node.debug('States Loaded');
    }

    onHaServicesLoaded(services) {
        this.setOnContext('services', services);
        this.node.debug('Services Loaded');
    }

    onHaEventsConnecting() {
        this.setOnContext('isConnected', false);
        this.setOnContext('isRunning', false);
        this.node.log(`Connecting to ${this.node.credentials.host}`);
    }

    onHaEventsClose() {
        if (this.getFromContext('isConnected')) {
            this.node.log(`Connection closed to ${this.node.credentials.host}`);
        }
        this.setOnContext('isConnected', false);
        this.setOnContext('isRunning', false);
    }

    onHaEventsRunning() {
        this.setOnContext('isRunning', true);
        this.node.debug(`HA State: running`);
    }

    onHaEventsError(err) {
        this.setOnContext('isConnected', false);
        this.setOnContext('isRunning', false);
        this.node.debug(err);
    }

    // Close WebSocket client on redeploy or node-RED shutdown
    onClose(removed, done) {
        if (this.homeAssistant) {
            this.node.log(
                `Closing connection to ${this.node.credentials.host}`
            );
            if (removed) {
                this.homeAssistant.close();
            }
        }
        done();
    }

    onIntegrationEvent(eventType) {
        if (
            eventType === INTEGRATION_NOT_LOADED$1 &&
            !this.isHomeAssistantRunning
        ) {
            return;
        }
        this.node.debug(`Integration: ${eventType}`);
    }

    registerEvents() {
        this.homeAssistant.subscribeEvents();
    }
}

var ConfigServer_1 = ConfigServer$1;

const Joi$6 = require$$0__default$3['default'];

const BaseNode$4 = BaseNode_1;
const RenderTemplate$6 = mustacheContext;

const nodeOptions$h = {
    config: {
        halt_if: {},
        halt_if_type: {},
        halt_if_compare: {},
        override_topic: {},
        entity_id: {},
        outputProperties: {},
        blockInputOverrides: {},
        // deprecated
        state_type: {},
        state_location: {},
        override_payload: {},
        entity_location: {},
        override_data: {},
    },
    input: {
        entity_id: {
            messageProp: 'payload.entity_id',
            configProp: 'entity_id',
            validation: {
                haltOnFail: true,
                schema: Joi$6.string().label('entity_id'),
            },
        },
    },
};

class CurrentState$1 extends BaseNode$4 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$h });
    }

    /* eslint-disable camelcase */
    onInput({ parsedMessage, message, send, done }) {
        const config = this.nodeConfig;
        const entityId = RenderTemplate$6(
            config.blockInputOverrides === true
                ? config.entity_id
                : parsedMessage.entity_id.value,
            message,
            this.node.context(),
            config.server.name
        );

        if (config.server === null) {
            done('No valid server selected.');
            return;
        }

        const entity = this.homeAssistant.getStates(entityId);
        if (!entity) {
            done(
                `Entity could not be found in cache for entity_id: ${entityId}`
            );
            return;
        }

        entity.timeSinceChangedMs =
            Date.now() - new Date(entity.last_changed).getTime();

        // Convert and save original state if needed
        this.castState(entity, config.state_type);

        const isIfState = this.getComparatorResult(
            config.halt_if_compare,
            config.halt_if,
            entity.state,
            config.halt_if_type,
            {
                message,
                entity,
            }
        );

        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                entity,
                entityState: entity.state,
                triggerId: entityId,
            });
        } catch (e) {
            this.status.setFailed('error');
            done(e.message);
            return;
        }

        if (config.halt_if && !isIfState) {
            this.status.setFailed(entity.state);
            send([null, message]);
            done();
            return;
        }

        this.status.setSuccess(entity.state);
        send([message, null]);
        done();
    }
}

var CurrentState_1 = CurrentState$1;

const FileAsync = require$$0__default$8['default'];
const low = require$$1__default$4['default'];

let DB;

class Storage$1 {
    constructor({ id, path }) {
        this.id = id;
        this.path = path;
    }

    get databaseId() {
        return `nodes.${this.id.replace('.', '_')}`;
    }

    async getDb() {
        if (DB) return DB;

        if (!this.path) {
            throw new Error('Could not find userDir to use for database store');
        }
        const dbLocation = `${this.path}/node-red-contrib-home-assistant-websocket.json`;

        const adapter = new FileAsync(dbLocation);
        DB = await low(adapter);
        DB.defaults({
            nodes: {},
        });

        return DB;
    }

    // namespaces data by nodeid to the lowdb store
    async saveData(key, value) {
        if (!this.id || !key) {
            throw new Error('cannot persist data to db without id and key');
        }
        const path = `${this.databaseId}.${key}`;
        const db = await this.getDb();

        return db.set(path, value).write();
    }

    async getData(key) {
        if (!this.id) {
            throw new Error('cannot get node data from db without id');
        }
        const db = await this.getDb();
        let path = `${this.databaseId}`;
        if (key) path = path + `.${key}`;

        return db.get(path).value();
    }

    async removeData() {
        if (!this.id) {
            throw new Error('cannot get node data from db without id');
        }
        const db = await this.getDb();

        return db.unset(this.databaseId).write();
    }
}

var Storage_1 = Storage$1;

const {
    STATE_CONNECTED,
    STATE_CONNECTING,
    STATE_DISCONNECTED,
    STATE_ERROR,
    STATE_RUNNING,
} = _const;

const STATUS_COLOR_BLUE$1 = 'blue';
const STATUS_COLOR_GREEN$1 = 'green';
const STATUS_COLOR_GREY = 'grey';
const STATUS_COLOR_RED = 'red';
const STATUS_COLOR_YELLOW = 'yellow';
const STATUS_SHAPE_DOT$1 = 'dot';
const STATUS_SHAPE_RING$2 = 'ring';

class Status$1 {
    constructor(node) {
        this.node = node;
        this.isNodeDisabled = false;
        this.lastStatus = {};
    }

    init() {}

    setNodeState(value) {
        if (this.isNodeDisabled === value) {
            this.isNodeDisabled = !value;
            this.updateStatus(this.lastStatus);
        }
    }

    set({
        fill = STATUS_COLOR_BLUE$1,
        shape = STATUS_SHAPE_DOT$1,
        text = '',
    } = {}) {
        const status = {
            fill,
            shape,
            text,
        };
        if (this.isNodeDisabled === false) {
            this.lastStatus = status;
        }
        this.updateStatus(status);
    }

    setText(text = '') {
        this.set({ fill: null, shape: null, text });
    }

    setSuccess(text = 'Success') {
        this.set({
            fill: STATUS_COLOR_GREEN$1,
            shape: STATUS_SHAPE_DOT$1,
            text: this.appendDateString(text),
        });
    }

    setSending(text = 'Sending') {
        this.set({
            fill: STATUS_COLOR_YELLOW,
            shape: STATUS_SHAPE_DOT$1,
            text: this.appendDateString(text),
        });
    }

    setFailed(text = 'Failed') {
        this.set({
            fill: STATUS_COLOR_RED,
            shape: STATUS_SHAPE_RING$2,
            text: this.appendDateString(text),
        });
    }

    updateStatus(status) {
        if (this.isNodeDisabled) {
            status = {
                fill: STATUS_COLOR_GREY,
                shape: STATUS_SHAPE_DOT$1,
                text: 'config-server.status.disabled',
            };
        }

        this.node.status(status);
    }

    appendDateString(text) {
        return `${text} at: ${this.getPrettyDate()}`;
    }

    destroy() {}

    getPrettyDate() {
        return new Date().toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            hour12: false,
            hour: 'numeric',
            minute: 'numeric',
        });
    }
}

class EventsStatus$1 extends Status$1 {
    constructor(node) {
        super(node);
        this.connectionState = STATE_DISCONNECTED;
        this.eventListeners = [];
    }

    init({ nodeState, homeAssistant }) {
        if (nodeState !== undefined) {
            this.isNodeDisabled = !nodeState;
        }

        if (homeAssistant) {
            this.enableConnectionStatus(homeAssistant);
        }
    }

    enableConnectionStatus(homeAssistant) {
        // Setup event listeners
        const events = {
            'ha_client:close': this.onClientClose,
            'ha_client:connecting': this.onClientConnecting,
            'ha_client:error': this.onClientError,
            'ha_client:open': this.onClientOpen,
            'ha_client:running': this.onClientRunning,
        };

        Object.entries(events).forEach(([event, callback]) => {
            this.eventListeners.push(() =>
                homeAssistant.removeListener(event, callback)
            );
            homeAssistant.addListener(event, callback.bind(this));
        });
    }

    onClientClose() {
        this.connectionState = STATE_DISCONNECTED;
        this.updateConnectionStatus();
    }

    onClientConnecting() {
        this.connectionState = STATE_CONNECTING;
        this.updateConnectionStatus();
    }

    onClientError() {
        this.connectionState = STATE_ERROR;
        this.updateConnectionStatus();
    }

    onClientOpen() {
        this.connectionState = STATE_CONNECTED;
        this.updateConnectionStatus();
    }

    onClientRunning() {
        this.connectionState = STATE_RUNNING;
        this.updateConnectionStatus();
    }

    updateConnectionStatus() {
        const status = this.getConnectionStatus();
        this.updateStatus(status);
    }

    getConnectionStatus() {
        const status = {
            fill: STATUS_COLOR_RED,
            shape: STATUS_SHAPE_RING$2,
            text: 'config-server.status.disconnected',
        };

        switch (this.connectionState) {
            case STATE_CONNECTED:
                status.fill = STATUS_COLOR_GREEN$1;
                status.text = 'config-server.status.connected';
                break;
            case STATE_CONNECTING:
                status.fill = STATUS_COLOR_YELLOW;
                status.text = 'config-server.status.connecting';
                break;
            case STATE_ERROR:
                status.text = 'config-server.status.error';
                break;
            case STATE_RUNNING:
                status.fill = STATUS_COLOR_GREEN$1;
                status.text = 'config-server.status.running';
                break;
        }

        return status;
    }

    destroy() {
        this.eventListeners.forEach((callback) => callback());
    }
}

class SwitchEntityStatus$1 extends Status$1 {
    set({
        fill = STATUS_COLOR_YELLOW,
        shape = STATUS_SHAPE_DOT$1,
        text = '',
    } = {}) {
        const status = {
            fill,
            shape,
            text,
        };
        super.set(status);
    }

    setNodeState(value) {
        this.isNodeDisabled = !value;

        const status = {
            fill: STATUS_COLOR_YELLOW,
            shape: value ? STATUS_SHAPE_DOT$1 : STATUS_SHAPE_RING$2,
            text: this.appendDateString(value ? 'on' : 'off'),
        };

        this.updateStatus(status);
    }

    updateStatus(status) {
        this.node.status(status);
    }
}

var status = {
    EventsStatus: EventsStatus$1,
    Status: Status$1,
    SwitchEntityStatus: SwitchEntityStatus$1,
    STATUS_COLOR_BLUE: STATUS_COLOR_BLUE$1,
    STATUS_COLOR_GREEN: STATUS_COLOR_GREEN$1,
    STATUS_COLOR_GREY,
    STATUS_COLOR_RED,
    STATUS_COLOR_YELLOW,
    STATUS_SHAPE_DOT: STATUS_SHAPE_DOT$1,
    STATUS_SHAPE_RING: STATUS_SHAPE_RING$2,
};

const Joi$5 = require$$0__default$3['default'];
const merge$1 = require$$0__default['default'];

const EventsNode$2 = EventsNode_1;
const Storage = Storage_1;
const { INTEGRATION_UNLOADED: INTEGRATION_UNLOADED$2, INTEGRATION_NOT_LOADED } = _const;
const { STATUS_SHAPE_DOT, STATUS_SHAPE_RING: STATUS_SHAPE_RING$1 } = status;

const DEFAULT_NODE_OPTIONS$1 = {
    debug: false,
    config: {
        haConfig: {},
        exposeToHomeAssistant: (nodeDef) =>
            nodeDef.exposeToHomeAssistant === undefined
                ? false
                : nodeDef.exposeToHomeAssistant,
    },
};

class EventsHaNode$a extends EventsNode$2 {
    constructor({ node, config, RED, status, nodeOptions = {} }) {
        nodeOptions = merge$1({}, DEFAULT_NODE_OPTIONS$1, nodeOptions);
        super({ node, config, RED, status, nodeOptions });
        this.storage = new Storage({
            id: this.node.id,
            path: RED.settings.userDir,
        });

        // Check if there's a server selected
        if (this.nodeConfig.server) {
            // Determine if node needs to be removed from Home Assistant because it's no longer exposed
            this.removeFromHA = !!(
                this.nodeConfig.exposeToHomeAssistant === false &&
                this.server.exposedNodes[this.id] === true
            );
            // Save expose state so we can check if it needs to removed when it's not exposed anymore
            this.server.exposedNodes[this.node.id] =
                this.nodeConfig.exposeToHomeAssistant;
        }
        this.init();
    }

    async init() {
        await this.loadPersistedData();

        if (this.isIntegrationLoaded) {
            this.registerEntity();
            this.removeFromHomeAssistant();
        }
    }

    async onClose(removed) {
        super.onClose(removed);

        if (removed) {
            if (
                this.isIntegrationLoaded &&
                this.nodeConfig.exposeToHomeAssistant
            ) {
                this.removeFromHomeAssistant(true);
            }
            await this.storage.removeData();
        }

        this.removeSubscription();
    }

    onHaEventsOpen() {
        this.subscription = null;
    }

    onHaIntegration(type) {
        super.onHaIntegration(type);

        switch (type) {
            case INTEGRATION_UNLOADED$2:
            case INTEGRATION_NOT_LOADED:
                this.removeSubscription();
                if (this.node.type !== 'trigger-state') {
                    this.isEnabled = true;
                }
                break;
        }
    }

    async loadPersistedData() {
        const data = await this.storage.getData().catch((e) => {
            this.node.error(e.message);
        });

        if (!data) return;

        if (Object.prototype.hasOwnProperty.call(data, 'isEnabled')) {
            this.isEnabled = data.isEnabled;
        }
        if (Object.prototype.hasOwnProperty.call(data, 'lastPayload')) {
            this.lastPayload = data.lastPayload;
        }
    }

    getDiscoveryPayload(config) {
        return {
            type: 'nodered/discovery',
            server_id: this.nodeConfig.server.id,
            node_id: this.node.id,
            component: 'switch',
            state: this.isEnabled,
            config,
        };
    }

    async registerEntity(status = true) {
        if (super.registerEntity() === false) {
            return;
        }

        const haConfig = {};
        // Handle both event node and sensor node switch HA config
        const config = this.nodeConfig.haConfig || this.nodeConfig.config;
        config
            .filter((c) => c.value.length)
            .forEach((e) => (haConfig[e.property] = e.value));

        try {
            const payload = this.getDiscoveryPayload(haConfig);
            this.node.debug(`Registering with Home Assistant`);
            this.subscription = await this.homeAssistant.subscribeMessage(
                this.onHaEventMessage.bind(this),
                payload,
                { resubscribe: false }
            );
        } catch (e) {
            this.status.setFailed(this.RED._('config-server.status.error'));
            this.node.error(e.message);
            return;
        }

        if (status) {
            this.status.setSuccess(
                this.RED._('config-server.status.registered')
            );
        }
        this.registered = true;
    }

    onHaEventMessage(evt) {
        if (evt.type === undefined) {
            // Need to set type prior to 0.20.0
            evt.type = 'state_changed';
        }
        if (evt.type) {
            switch (evt.type) {
                case 'state_changed':
                    this.isEnabled = evt.state;
                    this.storage.saveData('isEnabled', this.isEnabled);
                    this.updateHomeAssistant();
                    break;
                case 'automation_triggered':
                    this.handleTriggerMessage(evt.data);
                    break;
            }
        }
    }

    async handleTriggerMessage(data = {}) {
        if (this.isEnabled === false) {
            return;
        }

        const schema = Joi$5.object({
            entity_id: Joi$5.string().allow(null),
            skip_condition: Joi$5.boolean().default(false),
            output_path: Joi$5.boolean().default(true),
        });
        let validatedData, entity, entityId;

        try {
            validatedData = await schema.validateAsync(data);

            entityId = validatedData.entity_id || this.getNodeEntityId();

            if (!entityId) {
                throw new Error(
                    'Entity filter type is not set to exact and no entity_id found in trigger data.'
                );
            }

            entity = this.homeAssistant.getStates(entityId);

            if (!entity) {
                throw new Error(
                    `entity_id provided by trigger event not found in cache: ${entityId}`
                );
            }
        } catch (e) {
            this.status.setFailed('Error');
            this.node.error(`Trigger Error: ${e.message}`, {});
            return;
        }

        const eventMessage = {
            event_type: 'triggered',
            entity_id: entity.entity_id,
            event: {
                entity_id: entity.entity_id,
                old_state: entity,
                new_state: entity,
            },
        };

        if (!validatedData.skip_condition) {
            this.triggerNode(eventMessage);
            return;
        }

        const conditionalValue = validatedData.output_path;

        const msg = {
            topic: entityId,
            payload: eventMessage.event.new_state.state,
            data: eventMessage.event,
        };

        this.status.set({
            shape: conditionalValue ? STATUS_SHAPE_DOT : STATUS_SHAPE_RING$1,
            text: this.status.appendDateString(
                eventMessage.event.new_state.state
            ),
        });
        this.send(conditionalValue ? [msg, null] : [null, msg]);
    }

    getNodeEntityId() {}

    triggerNode() {}

    updateHomeAssistant() {
        if (!this.isIntegrationLoaded) return;

        const message = {
            type: 'nodered/entity',
            server_id: this.nodeConfig.server.id,
            node_id: this.node.id,
            state: this.isEnabled,
        };

        this.homeAssistant.send(message);
    }

    // Remove from Home Assistant when `Expose to Home Assistant` is unchecked
    removeFromHomeAssistant(nodeRemoved = false) {
        if (
            !this.homeAssistant.isIntegrationLoaded ||
            (!this.removeFromHA && !nodeRemoved) ||
            (this.nodeConfig.entityType &&
                this.nodeConfig.entityType !== 'switch')
        ) {
            return;
        }

        const payload = {
            type: 'nodered/discovery',
            server_id: this.nodeConfig.server.id,
            node_id: this.node.id,
            component: 'switch',
            remove: true,
        };

        this.homeAssistant.send(payload);
        this.removeFromHA = false;
        this.removeSubscription();

        // Enabled node when removing it from Home Assistant as there is no
        // way to do so once it's removed except for the trigger-state node
        this.isEnabled = true;
        this.storage.saveData('isEnabled', this.isEnabled);
    }

    async removeSubscription() {
        if (this.subscription) {
            this.node.debug('Unregistering from HA');
            await this.subscription().catch(() => {});
        }
        this.subscription = null;
    }
}

var EventsHaNode_1 = EventsHaNode$a;

const EventsHaNode$9 = EventsHaNode_1;

const nodeOptions$g = {
    config: {
        device: {},
        deviceType: {},
        event: {},
        capabilities: {},
        outputProperties: {},
        exposeToHomeAssistant: () => false,
    },
};

class DeviceAction$1 extends EventsHaNode$9 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$g });
    }

    async onInput({ message, send, done }) {
        const payload = {
            type: 'nodered/device_action',
            action: this.nodeConfig.event,
        };
        await this.homeAssistant.send({ ...payload });

        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                data: payload,
            });
        } catch (e) {
            this.status.setFailed('error');
            done(e);
            return;
        }

        this.status.setSuccess(
            `${this.nodeConfig.event.domain}.${this.nodeConfig.event.type}`
        );
        send(message);
        done();
    }
}

var DeviceAction_1 = DeviceAction$1;

const EventsHaNode$8 = EventsHaNode_1;
const { ENTITY_DEVICE_TRIGGER } = _const;

const nodeOptions$f = {
    config: {
        device: {},
        deviceType: {},
        event: {},
        capabilities: {},
        outputProperties: {},
        exposeToHomeAssistant: () => true,
    },
};

class DeviceTrigger$1 extends EventsHaNode$8 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$f });
    }

    getDiscoveryPayload(config) {
        const payload = super.getDiscoveryPayload(config);
        return {
            ...payload,
            sub_type: ENTITY_DEVICE_TRIGGER,
            device_trigger: this.getTriggerData(),
        };
    }

    getTriggerData() {
        if (!this.nodeConfig.event) {
            throw new Error(
                this.RED._('ha-device.error.invalid_device_config')
            );
        }

        const trigger = { ...this.nodeConfig.event };
        if (
            this.nodeConfig.capabilities &&
            this.nodeConfig.capabilities.length
        ) {
            this.nodeConfig.capabilities.forEach((cap) => {
                trigger[cap.name] = this.getCapabilitiesValue(cap);
            });
        }

        return trigger;
    }

    getCapabilitiesValue(cap) {
        switch (cap.type) {
            case 'positive_time_period_dict': {
                const unit = cap.unit || 'seconds';
                return { [unit]: cap.value };
            }
            case 'float':
                return Number(cap.value);
            case 'string':
            default:
                return cap.value;
        }
    }

    onHaEventMessage(event) {
        if (event.type === 'device_trigger') {
            this.onTrigger(event.data);
        } else {
            super.onHaEventMessage(event);
        }
    }

    onTrigger(data) {
        if (!this.isEnabled) return;

        const message = {};

        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                eventData: data,
                triggerId: this.nodeConfig.device,
            });
        } catch (e) {
            this.status.setFailed(this.RED._('config-server.status.error'));
            this.node.error(e);
            return;
        }

        this.status.setSuccess(this.RED._('config-server.status.triggered'));
        this.send(message);
    }
}

var DeviceTrigger_1 = DeviceTrigger$1;

const EventsHaNode$7 = EventsHaNode_1;

const nodeOptions$e = {
    config: {
        event_type: (nodeDef) => (nodeDef.event_type || '').trim(),
        waitForRunning: {},
        outputProperties: {},
    },
};

class EventsAll$1 extends EventsHaNode$7 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$e });

        this.addEventClientListener(
            'ha_events:' + (this.nodeConfig.event_type || 'all'),
            this.onHaEventsAll.bind(this)
        );
        if (
            !this.nodeConfig.event_type ||
            this.nodeConfig.event_type === 'home_assistant_client'
        ) {
            this.addEventClientListener(
                'ha_client:states_loaded',
                this.onClientStatesLoaded.bind(this)
            );
            this.addEventClientListener(
                'ha_client:services_loaded',
                this.onClientServicesLoaded.bind(this)
            );
            this.addEventClientListener(
                'ha_client:running',
                this.onHaEventsRunning.bind(this)
            );
            this.addEventClientListener(
                'ha_client:ready',
                this.onHaEventsReady.bind(this)
            );
        }

        // Registering only needed event types
        if (this.homeAssistant) {
            this.homeAssistant.eventsList[this.node.id] =
                this.nodeConfig.event_type || '__ALL__';
            this.updateEventList();
        }
    }

    onHaEventsAll(evt) {
        if (this.isEnabled === false) return;

        if (
            !this.isHomeAssistantRunning &&
            this.nodeConfig.waitForRunning === true
        ) {
            return;
        }

        const message = {};
        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                eventData: evt,
            });
        } catch (e) {
            this.status.setFailed('error');
            return;
        }

        this.status.setSuccess(evt.event_type);
        this.send(message);
    }

    clientEvent(type, data) {
        if (this.isEnabled === false) return;

        if (
            !this.nodeConfig.event_type ||
            this.nodeConfig.event_type === 'home_assistant_client'
        ) {
            this.send({
                event_type: 'home_assistant_client',
                topic: `home_assistant_client:${type}`,
                payload: type,
                data: data,
            });

            if (type === 'states_loaded' || type === 'services_loaded') {
                this.status.setSuccess(type);
            }
        }
    }

    onClose(nodeRemoved) {
        super.onClose(nodeRemoved);

        if (nodeRemoved) {
            delete this.homeAssistant.eventsList[this.node.id];
            this.updateEventList();
        }
    }

    onHaEventsClose() {
        super.onHaEventsClose();
        this.clientEvent('disconnected');
    }

    onHaEventsOpen() {
        super.onHaEventsOpen();
        this.clientEvent('connected');
    }

    onHaEventsConnecting() {
        super.onHaEventsConnecting();
        this.clientEvent('connecting');
    }

    onHaEventsRunning() {
        this.clientEvent('running');
    }

    onHaEventsReady() {
        this.clientEvent('ready');
    }

    onHaEventsError(err) {
        super.onHaEventsError(err);
        if (err) {
            this.clientEvent('error', err.message);
        }
    }

    onClientStatesLoaded() {
        this.clientEvent('states_loaded');
    }

    onClientServicesLoaded() {
        this.clientEvent('services_loaded');
    }

    updateEventList() {
        if (this.isConnected) {
            this.homeAssistant.subscribeEvents();
        }
    }
}

var EventsAll_1 = EventsAll$1;

const cloneDeep$4 = require$$0__default$6['default'];
const selectn$5 = require$$1__default$1['default'];

const EventsHaNode$6 = EventsHaNode_1;
const {
    shouldIncludeEvent: shouldIncludeEvent$2,
    getWaitStatusText: getWaitStatusText$1,
    getTimeInMilliseconds: getTimeInMilliseconds$2,
} = utils;

const nodeOptions$d = {
    config: {
        entityidfilter: (nodeDef) => (nodeDef.entityidfilter || '').trim(),
        entityidfiltertype: {},
        haltIfState: (nodeDef) =>
            nodeDef.haltifstate ? nodeDef.haltifstate.trim() : null,
        halt_if_type: {},
        halt_if_compare: {},
        outputinitially: {},
        state_type: {},
        output_only_on_state_change: {},
        for: {},
        forType: {},
        forUnits: {},
        ignorePrevStateNull: {},
        ignorePrevStateUnknown: {},
        ignorePrevStateUnavailable: {},
        ignoreCurrentStateUnknown: {},
        ignoreCurrentStateUnavailable: {},
        outputProperties: {},
    },
};

class EventsState$1 extends EventsHaNode$6 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$d });
        let eventTopic = 'ha_events:state_changed';
        this.topics = [];

        if (this.nodeConfig.entityidfiltertype === 'exact') {
            eventTopic =
                this.eventTopic = `ha_events:state_changed:${this.nodeConfig.entityidfilter}`;
        }

        this.addEventClientListener(
            eventTopic,
            this.onHaEventsStateChanged.bind(this)
        );

        if (this.nodeConfig.outputinitially) {
            // Here for when the node is deploy without the server config being deployed
            if (this.isHomeAssistantRunning) {
                this.onDeploy();
            } else {
                this.addEventClientListener(
                    'ha_client:initial_connection_ready',
                    this.onStatesLoaded.bind(this)
                );
            }
        }
    }

    onHaEventsStateChanged(evt, runAll) {
        if (
            this.isEnabled === false ||
            !this.isHomeAssistantRunning ||
            !this.isEventValid(evt)
        ) {
            return;
        }

        const config = this.nodeConfig;
        const eventMessage = cloneDeep$4(evt);
        const entityId = eventMessage.entity_id;
        const oldEntity = selectn$5('event.old_state', eventMessage);
        const newEntity = selectn$5('event.new_state', eventMessage);
        // Convert and save original state if needed
        this.castState(oldEntity, config.state_type);
        this.castState(newEntity, config.state_type);
        const oldState = oldEntity ? oldEntity.state : undefined;
        const newState = newEntity ? newEntity.state : undefined;

        // Output only on state change
        if (
            runAll === undefined &&
            config.output_only_on_state_change === true &&
            oldState === newState
        ) {
            return;
        }

        // Get if state condition
        const isIfState = this.getComparatorResult(
            config.halt_if_compare,
            config.haltIfState,
            newState,
            config.halt_if_type,
            {
                entity: newEntity,
                prevEntity: oldEntity,
            }
        );

        // Track multiple entity ids
        this.topics[entityId] = this.topics[entityId] || {};

        let timer;
        try {
            timer = this.getTimerValue();
        } catch (e) {
            this.node.error(e.message);
            this.status.setFailed('Error');
            return;
        }
        const validTimer = timer > 0;

        if (validTimer) {
            if (
                // If the ifState is not used and prev and current state are the same return because timer should already be running
                oldState === newState ||
                // Don't run timers for on connection updates
                runAll ||
                // Timer already active and ifState is still true turn don't update
                (config.haltIfState &&
                    isIfState &&
                    this.topics[entityId].active)
            ) {
                return;
            }

            if (config.haltIfState && !isIfState) {
                this.topics[entityId].active = false;
            }
        }

        if (
            !validTimer ||
            (config.haltIfState && !isIfState) ||
            eventMessage.event_type === 'triggered'
        ) {
            this.output(eventMessage, isIfState);
            return;
        }

        const statusText = getWaitStatusText$1(timer, this.nodeConfig.forUnits);
        const timeout = getTimeInMilliseconds$2(timer, this.nodeConfig.forUnits);

        this.status.setText(statusText);

        clearTimeout(this.topics[entityId].id);
        this.topics[entityId].active = true;
        this.topics[entityId].id = setTimeout(
            this.output.bind(this, eventMessage, isIfState),
            timeout
        );
    }

    getTimerValue() {
        if (this.nodeConfig.for === '') return 0;
        const timer = this.getTypedInputValue(
            this.nodeConfig.for,
            this.nodeConfig.forType
        );

        if (isNaN(timer) || timer < 0) {
            throw new Error(`Invalid value for 'for': ${timer}`);
        }

        return timer;
    }

    output(eventMessage, condition) {
        const config = this.nodeConfig;
        const message = {};
        try {
            this.setCustomOutputs(config.outputProperties, message, {
                config,
                entity: eventMessage.event.new_state,
                entityState: eventMessage.event.new_state.state,
                eventData: eventMessage.event,
                prevEntity: eventMessage.event.old_state,
                triggerId: eventMessage.entity_id,
            });
        } catch (e) {
            this.status.setFailed('error');
            return;
        }

        eventMessage.event.new_state.timeSinceChangedMs =
            Date.now() -
            new Date(eventMessage.event.new_state.last_changed).getTime();

        const statusMessage = `${eventMessage.event.new_state.state}${
            eventMessage.event.event_type === 'triggered' ? ` (triggered)` : ''
        }`;

        clearTimeout(this.topics[eventMessage.entity_id].id);

        if (config.haltIfState && !condition) {
            this.status.setFailed(statusMessage);
            this.send([null, message]);
            return;
        }

        this.status.setSuccess(statusMessage);
        this.send([message, null]);
    }

    getNodeEntityId() {
        return (
            this.nodeConfig.entityidfiltertype === 'exact' &&
            this.nodeConfig.entityidfilter
        );
    }

    triggerNode(eventMessage) {
        this.onHaEventsStateChanged(eventMessage, false);
    }

    onDeploy() {
        const entities = this.homeAssistant.getStates();
        this.onStatesLoaded(entities);
    }

    onStatesLoaded(entities) {
        if (!this.isEnabled) return;

        for (const entityId in entities) {
            const eventMessage = {
                event_type: 'state_changed',
                entity_id: entityId,
                event: {
                    entity_id: entityId,
                    old_state: entities[entityId],
                    new_state: entities[entityId],
                },
            };

            this.onHaEventsStateChanged(eventMessage, true);
        }
    }

    isEventValid(evt) {
        if (
            !shouldIncludeEvent$2(
                evt.entity_id,
                this.nodeConfig.entityidfilter,
                this.nodeConfig.entityidfiltertype
            ) ||
            (this.nodeConfig.ignorePrevStateNull && !evt.event.old_state) ||
            (this.nodeConfig.ignorePrevStateUnknown &&
                evt.event.old_state.state === 'unknown') ||
            (this.nodeConfig.ignorePrevStateUnavailable &&
                evt.event.old_state.state === 'unavailable') ||
            (this.nodeConfig.ignoreCurrentStateUnknown &&
                evt.event.new_state.state === 'unknown') ||
            (this.nodeConfig.ignoreCurrentStateUnavailable &&
                evt.event.new_state.state === 'unavailable')
        ) {
            return false;
        }

        return true;
    }
}

var EventsState_1 = EventsState$1;

const Joi$4 = require$$0__default$3['default'];

const BaseNode$3 = BaseNode_1;
const RenderTemplate$5 = mustacheContext;

const nodeOptions$c = {
    config: {
        name: {},
        server: { isNode: true },
        event: {},
        data: {},
        dataType: (nodeDef) => nodeDef.dataType || 'json',
    },
    input: {
        event: {
            messageProp: 'payload.event',
            configProp: 'event',
            validation: {
                haltOnFail: true,
                schema: Joi$4.string().label('event'),
            },
        },
        data: {
            messageProp: 'payload.data',
            configProp: 'data',
            validation: {
                haltOnFail: false,
                schema: Joi$4.string().label('data'),
            },
        },
        dataType: {
            messageProp: 'payload.dataType',
            configProp: 'dataType',
            default: 'json',
            validation: {
                haltOnFail: true,
                schema: Joi$4.string().valid('json', 'jsonata').label('dataType'),
            },
        },
    },
};

class FireEvent$1 extends BaseNode$3 {
    constructor({ node, RED, status, config }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$c });
    }

    tryToObject(v) {
        if (!v) return null;
        try {
            return JSON.parse(v);
        } catch (e) {
            return v;
        }
    }

    onInput({ message, parsedMessage, send, done }) {
        if (!this.homeAssistant) {
            this.status.setFailed('No server');
            done('No valid Home Assistant server selected.');
            return;
        }

        const eventType = RenderTemplate$5(
            parsedMessage.event.value,
            message,
            this.node.context(),
            this.nodeConfig.server.name
        );
        let eventData;
        if (parsedMessage.dataType.value === 'jsonata') {
            try {
                eventData = JSON.stringify(
                    this.evaluateJSONata(parsedMessage.data.value, { message })
                );
            } catch (e) {
                this.status.setFailed('Error');
                done(e.message);
                return;
            }
        } else {
            eventData = RenderTemplate$5(
                typeof parsedMessage.data.value === 'object'
                    ? JSON.stringify(parsedMessage.data.value)
                    : parsedMessage.data.value,
                message,
                this.node.context(),
                this.nodeConfig.server.name
            );
        }

        this.node.debug(`Fire Event: ${eventType} -- ${JSON.stringify({})}`);

        message.payload = {
            event: eventType,
            data: eventData || null,
        };

        this.status.setSending();

        return this.homeAssistant
            .fireEvent(eventType, eventData)
            .then(() => {
                this.status.setSuccess(eventType);
                send(message);
                done();
            })
            .catch((err) => {
                this.status.setFailed('API Error');
                done(
                    `Error firing event, home assistant rest api error: ${err.message}`
                );
            });
    }
}

var FireEvent_1 = FireEvent$1;

const Joi$3 = require$$0__default$3['default'];
const selectn$4 = require$$1__default$1['default'];
const { shuffle } = require$$2__default$3['default'];

const BaseNode$2 = BaseNode_1;

const nodeOptions$b = {
    debug: true,
    config: {
        server: { isNode: true },
        name: {},
        rules: {},
        output_type: {},
        output_empty_results: {},
        output_location_type: {},
        output_location: {},
        output_results_count: {},
    },
    input: {
        outputType: {
            messageProp: 'payload.outputType',
            configProp: 'output_type',
            default: 'array',
            validation: {
                haltOnFail: true,
                schema: Joi$3.string()
                    .valid('array', 'count', 'random', 'split')
                    .label('OutputType'),
            },
        },
        outputEmptyResults: {
            messageProp: 'payload.outputEmptyResults',
            configProp: 'output_empty_results',
            default: false,
            validation: {
                haltOnFail: true,
                schema: Joi$3.boolean().label('outputEmptyResults'),
            },
        },
        outputLocationType: {
            messageProp: 'payload.outputLocationType',
            configProp: 'output_location_type',
            default: 'msg',
            validation: {
                haltOnFail: true,
                schema: Joi$3.string()
                    .valid('array', 'msg', 'flow', 'global')
                    .label('outputLocationType'),
            },
        },
        outputLocation: {
            messageProp: 'payload.outputLocation',
            configProp: 'output_location',
            default: 'payload',
            validation: {
                haltOnFail: true,
                schema: Joi$3.string().label('outputLocation'),
            },
        },
        outputResultsCount: {
            messageProp: 'payload.outputResultsCount',
            configProp: 'output_results_count',
            default: 1,
            validation: {
                haltOnFail: true,
                schema: Joi$3.number().label('outputResultsCount'),
            },
        },
        rules: {
            messageProp: 'payload.rules',
            configProp: 'rules',
            default: [],
            validation: {
                haltOnFail: true,
                schema: Joi$3.array()
                    .items(
                        Joi$3.object({
                            property: Joi$3.when('logic', {
                                is: 'jsonata',
                                then: Joi$3.any(),
                                otherwise: Joi$3.string(),
                            }),
                            logic: Joi$3.string().valid(
                                'is',
                                'is_not',
                                'lt',
                                'lte',
                                'gt',
                                'gte',
                                'includes',
                                'does_not_include',
                                'starts_with',
                                'in_group',
                                'jsonata'
                            ),
                            value: Joi$3.string(),
                            valueType: Joi$3.string().valid(
                                'str',
                                'num',
                                'bool',
                                're',
                                'jsonata',
                                'msg',
                                'flow',
                                'global',
                                'entity'
                            ),
                        })
                    )
                    .label('rules'),
            },
        },
    },
};

class GetEntities$1 extends BaseNode$2 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$b });
    }

    /* eslint-disable camelcase */
    onInput({ message, parsedMessage, send, done }) {
        let noPayload = false;

        if (this.nodeConfig.server === null) {
            done('No valid server selected.');
            return;
        }

        const states = this.homeAssistant.getStates();
        if (!states) {
            send({ payload: {} });
            done('local state cache missing sending empty payload');
        }

        let entities;
        try {
            entities = Object.values(states).filter((entity) => {
                const rules = parsedMessage.rules.value;

                entity.timeSinceChangedMs =
                    Date.now() - new Date(entity.last_changed).getTime();

                for (const rule of rules) {
                    const value = selectn$4(rule.property, entity);
                    const result = this.getComparatorResult(
                        rule.logic,
                        rule.value,
                        value,
                        rule.valueType,
                        {
                            message,
                            entity,
                        }
                    );
                    if (
                        (rule.logic !== 'jsonata' && value === undefined) ||
                        !result
                    ) {
                        return false;
                    }
                }

                return true;
            });
        } catch (e) {
            this.status.setFailed('Error');
            done(e.message);
            return;
        }

        let statusText = `${entities.length} entities`;
        let payload = {};

        switch (parsedMessage.outputType.value) {
            case 'count':
                payload = entities.length;
                break;
            case 'split':
                if (entities.length === 0) {
                    noPayload = true;
                    break;
                }

                this.status.setSuccess(statusText);
                this.sendSplit(message, entities, send);
                done();
                return;
            case 'random': {
                if (entities.length === 0) {
                    noPayload = true;
                    break;
                }
                const maxReturned =
                    Number(parsedMessage.outputResultsCount.value) || 1;

                const max =
                    entities.length <= maxReturned
                        ? entities.length
                        : maxReturned;
                const shuffledEntities = shuffle(entities);
                payload = shuffledEntities.slice(0, max);
                if (maxReturned === 1) {
                    payload = payload[0];
                }
                statusText = `${maxReturned === 1 ? 1 : payload.length} Random`;
                break;
            }
            case 'array':
            default:
                if (
                    entities.length === 0 &&
                    !parsedMessage.outputEmptyResults.value
                ) {
                    noPayload = true;
                }

                payload = entities;
                break;
        }

        if (noPayload) {
            this.status.setFailed('No Results');
            done();
            return;
        }

        this.status.setSuccess(statusText);

        this.setContextValue(
            payload,
            parsedMessage.outputLocationType.value,
            parsedMessage.outputLocation.value,
            message
        );

        send(message);
        done();
    }
}

var GetEntities_1 = GetEntities$1;

const Joi$2 = require$$0__default$3['default'];
const timestring = require$$1__default$5['default'];

const BaseNode$1 = BaseNode_1;
const RenderTemplate$4 = mustacheContext;

const nodeOptions$a = {
    debug: true,
    config: {
        name: {},
        server: { isNode: true },
        startdate: {},
        enddate: {},
        entityid: (nodeDef) => (nodeDef.entityid || '').trim(),
        entityidtype: {},
        useRelativeTime: {},
        relativeTime: {},
        flatten: {},
        output_type: {},
        output_location_type: {},
        output_location: {},
    },
    input: {
        startDate: {
            messageProp: ['payload.startdate', 'startdate'],
            configProp: 'startdate',
            default: () => {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                return yesterday.toISOString();
            },
            validation: {
                schema: Joi$2.date().optional().allow('').label('startdate'),
            },
        },
        endDate: {
            messageProp: ['payload.enddate', 'enddate'],
            configProp: 'enddate',
            validation: {
                schema: Joi$2.date().optional().allow('').label('enddate'),
            },
        },
        entityId: {
            messageProp: ['payload.entity_id', 'entityid'],
            configProp: 'entityid',
        },
        entityIdType: {
            messageProp: ['payload.entityidtype', 'entityidtype'],
            configProp: 'entityidtype',
        },
        relativeTime: {
            messageProp: ['payload.relativetime', 'relativetime'],
            configProp: 'relativeTime',
        },
        flatten: {
            messageProp: ['payload.flatten', 'flatten'],
            configProp: 'flatten',
        },
    },
};

class GetHistory$1 extends BaseNode$1 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$a });
    }

    async onInput({ parsedMessage, message, send, done }) {
        if (!this.homeAssistant) {
            this.status.setFailed('No server');
            done('No valid Home Assistant server selected.');
            return;
        }

        let {
            startDate,
            endDate,
            entityId,
            entityIdType,
            relativeTime,
            flatten,
        } = parsedMessage;
        startDate = startDate.value;
        endDate = endDate.value;
        entityId =
            parsedMessage.entityId.source === 'message'
                ? entityId.value
                : RenderTemplate$4(
                      entityId.value,
                      message,
                      this.node.context(),
                      this.nodeConfig.server.name
                  );
        relativeTime = relativeTime.value;
        flatten = flatten.value;
        const useRelativeTime = this.nodeConfig.useRelativeTime;

        if (
            useRelativeTime ||
            parsedMessage.relativeTime.source === 'message'
        ) {
            startDate = new Date(
                Date.now() - timestring(relativeTime, 'ms')
            ).toISOString();
            endDate = new Date().toISOString();
        }

        const apiRequest =
            entityIdType.value === 'includes' && entityId
                ? this.homeAssistant.getHistory(startDate, null, endDate, {
                      flatten: flatten,
                      include: new RegExp(entityId),
                  })
                : this.homeAssistant.getHistory(startDate, entityId, endDate, {
                      flatten: flatten,
                  });

        this.status.setSending('Requesting');

        let results;
        try {
            results = await apiRequest;
            message.startdate = startDate;
            message.enddate = endDate || null;
            message.entity_id = entityId || null;
        } catch (err) {
            this.status.setFailed('Error');
            done(`Error get-history: ${err.message}`);
            return;
        }

        switch (this.nodeConfig.output_type) {
            case 'split':
                if (results.length === 0) {
                    this.status.setFailed('No Results');
                    return;
                }
                if (entityIdType.value === 'is' && !flatten) {
                    results = results[0];
                }

                this.sendSplit(message, results, send);
                break;

            case 'array':
            default:
                this.setContextValue(
                    results,
                    this.nodeConfig.output_location_type,
                    this.nodeConfig.output_location,
                    message
                );

                send(message);
                break;
        }

        this.status.setSuccess();
        done();
    }
}

var GetHistory_1 = GetHistory$1;

const ta = require$$0__default$9['default'];

const EventsHaNode$5 = EventsHaNode_1;

const nodeOptions$9 = {
    config: {
        entity_id: (nodeDef) => (nodeDef.entity_id || '').trim(),
        updateinterval: (nodeDef) =>
            !isNaN(nodeDef.updateinterval)
                ? Number(nodeDef.updateinterval)
                : 60,
        updateIntervalUnits: {},
        outputinitially: {},
        outputonchanged: {},
        state_type: {},
        halt_if: {},
        halt_if_type: {},
        halt_if_compare: {},
    },
};

class PollState$1 extends EventsHaNode$5 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$9 });

        if (!this.nodeConfig.entity_id) {
            throw new Error('Entity Id is required');
        }

        if (!this.timer) {
            const interval = this.nodeConfig.updateinterval;

            switch (this.nodeConfig.updateIntervalUnits) {
                case 'minutes':
                    this.updateInterval = interval * (60 * 1000);
                    break;
                case 'hours':
                    this.updateInterval = interval * (60 * 60 * 1000);
                    break;
                default:
                    this.updateInterval = interval * 1000;
            }
            this.timer = setInterval(
                this.onTimer.bind(this),
                this.updateInterval
            );
        }

        if (this.nodeConfig.outputonchanged) {
            this.addEventClientListener(
                `ha_events:state_changed:${this.nodeConfig.entity_id}`,
                this.onTimer.bind(this)
            );
        }

        if (this.nodeConfig.outputinitially) {
            if (this.isHomeAssistantRunning) {
                this.onTimer();
            } else {
                this.addEventClientListener(
                    'ha_client:initial_connection_ready',
                    this.onTimer.bind(this)
                );
            }
        }
    }

    onClose(removed) {
        super.onClose(removed);
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
    }

    onTimer(triggered = false) {
        if (!this.isHomeAssistantRunning || this.isEnabled === false) {
            return;
        }

        const pollState = this.homeAssistant.getStates(
            this.nodeConfig.entity_id
        );
        if (!pollState) {
            this.node.error(
                `could not find state with entity_id "${this.nodeConfig.entity_id}"`,
                {}
            );
            this.status.setText(
                `no state found for ${this.nodeConfig.entity_id}`
            );
            return;
        }

        const dateChanged = this.calculateTimeSinceChanged(pollState);
        if (!dateChanged) {
            this.node.error(
                `could not calculate time since changed for entity_id "${this.nodeConfig.entity_id}"`,
                {}
            );
            return;
        }
        pollState.timeSinceChanged = ta.ago(dateChanged);
        pollState.timeSinceChangedMs = Date.now() - dateChanged.getTime();

        // Convert and save original state if needed
        this.castState(pollState, this.nodeConfig.state_type);

        const msg = {
            topic: this.nodeConfig.entity_id,
            payload: pollState.state,
            data: pollState,
        };

        let isIfState;
        try {
            isIfState = this.getComparatorResult(
                this.nodeConfig.halt_if_compare,
                this.nodeConfig.halt_if,
                pollState.state,
                this.nodeConfig.halt_if_type,
                {
                    entity: pollState,
                }
            );
        } catch (e) {
            this.status.setFailed('Error');
            this.node.error(e.message, {});
            return;
        }

        const statusMessage = `${pollState.state}${
            triggered === true ? ` (triggered)` : ''
        }`;

        // Check 'if state' and send to correct output
        if (this.nodeConfig.halt_if && !isIfState) {
            this.status.setFailed(statusMessage);
            this.send([null, msg]);
            return;
        }

        this.status.setSuccess(statusMessage);
        this.send([msg, null]);
    }

    getNodeEntityId() {
        return this.nodeConfig.entity_id;
    }

    triggerNode(eventMessage) {
        this.onTimer(true);
    }

    calculateTimeSinceChanged(entityState) {
        const entityLastChanged = entityState.last_changed;
        return new Date(entityLastChanged);
    }
}

var PollState_1 = PollState$1;

const Joi$1 = require$$0__default$3['default'];

const BaseNode = BaseNode_1;

const nodeOptions$8 = {
    debug: true,
    config: {
        name: {},
        server: { isNode: true },
        template: {},
        resultsLocation: {},
        resultsLocationType: {},
        templateLocation: {},
        templateLocationType: {},
    },
    input: {
        template: {
            messageProp: 'template',
            configProp: 'template',
            validation: {
                haltOnFail: true,
                schema: Joi$1.string().required().label('template'),
            },
        },
        resultsLocation: {
            messageProp: 'resultsLocation',
            configProp: 'resultsLocation',
            default: 'payload',
        },
        resultsLocationType: {
            messageProp: 'resultsLocationType',
            configProp: 'resultsLocationType',
            default: 'msg',
            validation: {
                haltOnFail: true,
                schema: Joi$1.string()
                    .valid('msg', 'flow', 'global', 'none')
                    .label('resultsLocationType'),
            },
        },
        templateLocation: {
            messageProp: 'templateLocation',
            configProp: 'templateLocation',
            default: 'template',
        },
        templateLocationType: {
            messageProp: 'templateLocationType',
            configProp: 'templateLocationType',
            default: 'msg',
            validation: {
                haltOnFail: true,
                schema: Joi$1.string()
                    .valid('msg', 'flow', 'global', 'none')
                    .label('templateLocationType'),
            },
        },
    },
};

class RenderTemplate$3 extends BaseNode {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$8 });
    }

    onInput({ parsedMessage, message, send, done }) {
        if (!this.homeAssistant) {
            this.status.setFailed('No server');
            done('No valid Home Assistant server selected.');
            return;
        }

        const {
            template,
            templateLocation,
            templateLocationType,
            resultsLocation,
            resultsLocationType,
        } = parsedMessage;

        this.status.setSending('Requesting');

        return this.homeAssistant
            .renderTemplate(template.value)
            .then((res) => {
                this.setContextValue(
                    template.value,
                    templateLocationType.value,
                    templateLocation.value,
                    message
                );
                this.setContextValue(
                    res,
                    resultsLocationType.value,
                    resultsLocation.value,
                    message
                );

                send(message);
                this.status.setSuccess();
                done();
            })
            .catch((err) => {
                this.status.setFailed('Error');
                done(`Error get-template: ${err.message}`);
            });
    }
}

var RenderTemplate_1 = RenderTemplate$3;

const merge = require$$0__default['default'];

const EventsHaNode$4 = EventsHaNode_1;
const { INTEGRATION_UNLOADED: INTEGRATION_UNLOADED$1 } = _const;

const DEFAULT_NODE_OPTIONS = {
    config: {
        outputs: 1,
        entityType: {},
        config: {},
        exposeToHomeAssistant: () => true,
    },
};

class EntityNode$2 extends EventsHaNode$4 {
    constructor({ node, config, RED, status, nodeOptions = {} }) {
        nodeOptions = merge({}, DEFAULT_NODE_OPTIONS, nodeOptions);
        super({ node, config, RED, status, nodeOptions });
    }

    onHaIntegration(type) {
        super.onHaIntegration(type);

        if (type === INTEGRATION_UNLOADED$1) {
            this.node.error(
                'Node-RED custom integration has been removed from Home Assistant it is needed for this node to function.'
            );
            this.status.setFailed('Error');
        }
    }
}

var EntityNode_1 = EntityNode$2;

const slugify = require$$0__default$a['default'];

const EntityNode$1 = EntityNode_1;

const nodeOptions$7 = {
    config: {
        state: {},
        stateType: {},
        attributes: (nodeConfig) => nodeConfig.attributes || [],
        resend: {},
        outputLocation: {},
        outputLocationType: {},
        inputOverride: {},
    },
    input: {
        state: {
            messageProp: 'payload.state',
            configProp: 'state',
            default: 'payload',
        },
        stateType: {
            messageProp: 'payload.stateType',
            configProp: 'stateType',
            default: 'msg',
        },
        attributes: {
            messageProp: 'payload.attributes',
            configProp: 'attributes',
            default: [],
        },
    },
};

class Sensor$1 extends EntityNode$1 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$7 });
    }

    async registerEntity() {
        if (!this.isIntegrationLoaded) {
            this.error(this.integrationErrorMessage);
            this.status.setFailed('Error');
            return;
        }

        if (this.registered) {
            return;
        }

        const config = {};
        this.nodeConfig.config
            .filter((c) => c.value.length)
            .forEach((e) => (config[e.property] = e.value));

        const payload = {
            type: 'nodered/discovery',
            server_id: this.nodeConfig.server.id,
            node_id: this.node.id,
            component: this.nodeConfig.entityType,
            config: config,
        };

        // Add state and attributes to payload if resend enabled
        if (this.nodeConfig.resend && this.lastPayload) {
            payload.state = this.lastPayload.state;
            payload.attributes = this.lastPayload.attributes;
        }

        this.debugToClient(payload);

        this.node.debug(`Registering ${this.nodeConfig.entityType} with HA`);
        await this.homeAssistant.send(payload);
        this.status.setSuccess('Registered');
        this.registered = true;
    }

    onClose(removed) {
        super.onClose(removed);

        if (this.registered && this.isIntegrationLoaded && removed) {
            const payload = {
                type: 'nodered/discovery',
                server_id: this.nodeConfig.server.id,
                node_id: this.node.id,
                component: this.nodeConfig.entityType,
                remove: true,
            };
            this.node.debug(
                `Unregistering ${this.nodeConfig.entityType} from HA`
            );
            this.homeAssistant.send(payload);
        }
    }

    onInput({ parsedMessage, message, send, done }) {
        if (!this.isConnected) {
            this.status.setFailed('No Connection');
            done('Sensor update attempted without connection to server.');
            return;
        }

        if (!this.isIntegrationLoaded) {
            this.status.setFailed('Error');
            done(this.integrationErrorMessage);
            return;
        }

        let state = parsedMessage.state.value;
        let stateType = parsedMessage.stateType.value;
        if (this.nodeConfig.inputOverride === 'block') {
            state = this.nodeConfig.state;
            stateType = this.nodeConfig.stateType;
        } else if (
            parsedMessage.state.source === 'message' &&
            stateType !== 'message'
        ) {
            // Set default for state from input to string
            stateType = 'str';
        }

        try {
            state = this.getTypedInputValue(state, stateType, { message });
        } catch (e) {
            this.status.setFailed('Error');
            done(`State: ${e.message}`);
            return;
        }

        if (state === undefined) {
            this.status.setFailed('Error');
            done('State must be defined.');
            return;
        }

        const attributes = this.getAttributes(parsedMessage);

        const attr = {};
        try {
            attributes.forEach((x) => {
                // Change string to lower-case and remove unwanted characters
                const property = slugify(x.property, {
                    replacement: '_',
                    remove: /[^A-Za-z0-9-_~ ]/,
                    lower: true,
                });
                attr[property] = this.getTypedInputValue(x.value, x.valueType, {
                    message,
                });
            });
        } catch (e) {
            this.status.setFailed('Error');
            done(`Attribute: ${e.message}`);
            return;
        }

        const payload = {
            type: 'nodered/entity',
            server_id: this.nodeConfig.server.id,
            node_id: this.node.id,
            state: state,
            attributes: attr,
        };
        this.lastPayload = {
            state: state,
            attributes: attr,
        };
        this.storage.saveData('lastPayload', this.lastPayload);
        this.debugToClient(payload);

        this.homeAssistant
            .send(payload)
            .then(() => {
                this.status.setSuccess(state);

                if (this.nodeConfig.outputLocationType !== 'none') {
                    this.setContextValue(
                        payload,
                        this.nodeConfig.outputLocationType || 'msg',
                        this.nodeConfig.outputLocation || 'payload',
                        message
                    );
                }

                send(message);
                done();
            })
            .catch((err) => {
                this.status.setFailed('API Error');
                done(
                    `Entity API error. ${
                        err.message ? ` Error Message: ${err.message}` : ''
                    }`
                );
            });
    }

    getAttributes(parsedMessage) {
        let attributes = [];
        if (
            parsedMessage.attributes.source !== 'message' ||
            this.nodeConfig.inputOverride === 'block'
        ) {
            attributes = this.nodeConfig.attributes;
        } else {
            if (this.nodeConfig.inputOverride === 'merge') {
                const keys = Object.keys(parsedMessage.attributes.value).map(
                    (e) => e.toLowerCase()
                );
                this.nodeConfig.attributes.forEach((ele) => {
                    if (!keys.includes(ele.property.toLowerCase())) {
                        attributes.push(ele);
                    }
                });
            }
            for (const [prop, val] of Object.entries(
                parsedMessage.attributes.value
            )) {
                attributes.push({
                    property: prop,
                    value: val,
                });
            }
        }
        return attributes;
    }
}

var Sensor_1 = Sensor$1;

const EntityNode = EntityNode_1;
const {
    STATUS_SHAPE_RING,
    STATUS_COLOR_BLUE,
} = status;

const OUTPUT_TYPE_INPUT = 'input';
const OUTPUT_TYPE_STATE_CHANGE = 'state change';

const nodeOptions$6 = {
    config: {
        outputOnStateChange: {},
        outputPayload: {},
        outputPayloadType: {},
    },
};

class Switch$1 extends EntityNode {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$6 });

        this.status.init({
            nodeState: this.isEnabled,
            homeAssistant: this.homeAssistant,
        });
    }

    onHaEventMessage(evt) {
        super.onHaEventMessage(evt);
        if (
            evt.type === 'state_changed' &&
            this.nodeConfig.outputOnStateChange
        ) {
            // fake a HA entity
            const entity = {
                state: this.isEnabled,
            };
            let payload;
            try {
                payload = this.getTypedInputValue(
                    this.nodeConfig.outputPayload,
                    this.nodeConfig.outputPayloadType,
                    { entity }
                );
            } catch (e) {
                this.status.setFailed('Error');
                this.node.error(`JSONata Error: ${e.message}`, {});
                return;
            }

            const msg = {
                payload,
                outputType: OUTPUT_TYPE_STATE_CHANGE,
            };
            const opts = [msg, null];
            const statusMessage = msg.payload || 'state change';
            const status = {
                fill: STATUS_COLOR_BLUE,
                text: this.status.appendDateString(statusMessage),
            };
            if (this.isEnabled) {
                this.send(opts);
            } else {
                status.shape = STATUS_SHAPE_RING;
                this.send(opts.reverse());
            }
            this.status.set(status);
        }
    }

    onInput({ message, send, done }) {
        if (typeof message.enable === 'boolean') {
            this.isEnabled = message.enable;
            this.updateHomeAssistant();
            done();
            return;
        }

        message.outputType = OUTPUT_TYPE_INPUT;
        const output = [message, null];
        const statusMessage = message.payload || OUTPUT_TYPE_INPUT;
        if (this.isEnabled) {
            this.status.setSuccess(statusMessage);
            send(output);
        } else {
            this.status.setFailed(statusMessage);
            send(output.reverse());
        }
    }

    handleTriggerMessage(data = {}) {
        const msg = {
            topic: 'triggered',
            payload: data.payload,
        };

        if (this.isEnabled) {
            this.status.setSuccess('triggered');
            this.send([msg, null]);
        } else {
            this.status.setFailed('triggered');
            this.send([null, msg]);
        }
    }
}

var Switch_1 = Switch$1;

const cloneDeep$3 = require$$0__default$6['default'];

const EventsHaNode$3 = EventsHaNode_1;

const nodeOptions$5 = {
    config: {
        entities: {},
        tags: {},
        devices: {},
    },
};

class Tag$1 extends EventsHaNode$3 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$5 });

        this.addEventClientListener(
            `ha_events:tag_scanned`,
            this.onTagScanned.bind(this)
        );
    }

    async onTagScanned(evt) {
        if (this.isEnabled === false) return;

        const { event } = cloneDeep$3(evt);
        const { device_id: deviceId, tag_id: tagId } = event;

        if (!this.isValidTag(tagId) || !this.isValidDevice(deviceId)) return;

        const tagName = this.getTagName(tagId);
        const payload = {
            tag_name: tagName,
            user_id: evt.context.user_id,
            ...event,
        };

        const msg = {
            topic: tagId,
            payload,
        };

        this.status.setSuccess(`${tagName || tagId} scanned`);
        this.send(msg);
    }

    isValidTag(tag) {
        return this.nodeConfig.tags.includes(tag);
    }

    isValidDevice(deviceId) {
        const devices = this.nodeConfig.devices;
        return devices.length === 0 || devices.includes(deviceId);
    }

    getTagName(tagId) {
        return this.homeAssistant.getTags().find((tag) => tag.tag_id === tagId)
            .name;
    }
}

var Tag_1 = Tag$1;

const selectn$3 = require$$1__default$1['default'];
const { CronJob } = require$$1__default$6['default'];

const EventsHaNode$2 = EventsHaNode_1;
const {
    isValidDate,
    getTimeInMilliseconds: getTimeInMilliseconds$1,
    parseTime,
    getEntitiesFromJsonata,
} = utils;
const {
    TYPEDINPUT_BOOL,
    TYPEDINPUT_DATE,
    TYPEDINPUT_JSONATA,
    TYPEDINPUT_NUM,
    TYPEDINPUT_STR,
} = _const;
const { STATUS_COLOR_GREEN } = status;

const DEFAULT_PROPERTY = 'state';

const nodeOptions$4 = {
    config: {
        entityId: {},
        property: {},
        offset: {},
        offsetType: {},
        offsetUnits: {},
        randomOffset: {},
        repeatDaily: {},
        payload: {},
        payloadType: {},
    },
};

class Time$1 extends EventsHaNode$2 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$4 });
        this.cronjob = null;

        if (this.isHomeAssistantRunning) {
            this.onStateChanged();
        }
        this.addEventClientListener(
            'ha_client:ready',
            this.onStateChanged.bind(this)
        );

        this.addEventClientListener(
            `ha_events:state_changed:${this.nodeConfig.entityId}`,
            this.onStateChanged.bind(this)
        );

        if (
            this.nodeConfig.offsetType === TYPEDINPUT_JSONATA &&
            this.nodeConfig.offset.length > 12
        ) {
            const ids = getEntitiesFromJsonata(this.nodeConfig.offset);
            ids.forEach((id) => {
                this.addEventClientListener(
                    `ha_events:state_changed:${id}`,
                    this.onStateChanged.bind(this)
                );
            });
        }
    }

    onStateChanged() {
        if (this.isEnabled === false) {
            return;
        }
        const property = this.nodeConfig.property || DEFAULT_PROPERTY;
        const entity = this.getEntity();
        const dateString = selectn$3(property, entity);
        let crontab;
        let offset;

        this.destoryCronjob();

        // Validate inputs
        try {
            this.checkValidDateString(dateString);
            offset = this.getOffset();
            const digits = parseTime(dateString);

            // Doesn't match time format 00:00:00
            if (digits === null) {
                if (!isValidDate(dateString)) {
                    this.debugToClient(`Invalid date`);
                    throw new Error(this.RED._('ha-time.status.invalid_date'));
                }
                crontab = new Date(dateString);
            } else {
                crontab = new Date();
                crontab.setHours(digits.hour);
                crontab.setMinutes(digits.minutes);
                crontab.setSeconds(digits.seconds);
            }
        } catch (e) {
            this.debugToClient(e.message);
            this.status.setFailed(e.message);
            return;
        }

        // plus minus offset
        if (offset !== 0) {
            if (this.nodeConfig.randomOffset) {
                offset = this.getRandomOffset(crontab, offset);
            }
            const timestamp = crontab.getTime() + offset;
            crontab.setTime(timestamp);
        }

        // Create repeating crontab string
        if (this.nodeConfig.repeatDaily) {
            crontab = `${crontab.getSeconds()} ${crontab.getMinutes()} ${crontab.getHours()} * * *`;
        } else if (crontab.getTime() < Date.now()) {
            this.debugToClient(`date in the past`);
            this.status.setFailed(this.RED._('ha-time.status.in_the_past'));
            return;
        }

        this.createCronjob(crontab);

        const nextTime = this.formatDate(this.cronjob.nextDates().toDate());
        this.status.setText(this.RED._('ha-time.status.next_at', { nextTime }));
    }

    onInput({ msg, send, done }) {
        const now = new Date();
        const entity = this.getEntity();
        msg = {
            topic: this.nodeConfig.entityId,
            payload: this.getPayloadValue(
                this.nodeConfig.payloadType,
                this.nodeConfig.payload
            ),
            data: entity,
        };

        if (this.nodeConfig.repeatDaily) {
            const sentTime = this.formatDate(now);
            const nextTime = this.formatDate(this.cronjob.nextDates().toDate());
            this.status.set({
                text: this.RED._('ha-time.status.sent_and_next', {
                    sentTime,
                    nextTime,
                }),
                fill: STATUS_COLOR_GREEN,
            });
        } else {
            this.status.setSuccess(this.RED._('ha-time.status.sent'));
        }
        send(msg);
        done();
    }

    formatDate(d) {
        const year = d.getFullYear();
        const month = (d.getMonth() + 1).toString().padStart(2, '0');
        const day = d.getDate().toString().padStart(2, '0');
        const hours = d.getHours().toString().padStart(2, '0');
        const minutes = d.getMinutes().toString().padStart(2, '0');
        const seconds = d.getSeconds().toString().padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    onClose(removed) {
        super.onClose(removed);
        this.destoryCronjob();
    }

    onHaEventMessage(evt) {
        super.onHaEventMessage(evt);

        if (this.isEnabled) {
            this.onStateChanged();
        } else {
            this.destoryCronjob();
        }
    }

    registerEntity(status = true) {
        // Don't update status after registering
        super.registerEntity(false);
    }

    createCronjob(crontab) {
        const node = this.node;
        this.cronjob = new CronJob({
            cronTime: crontab,
            onTick: () => {
                node.emit('input', {});
            },
            start: true,
        });
    }

    destoryCronjob() {
        if (this.cronjob != null) {
            this.cronjob.stop();
            delete this.cronjob;
        }
    }

    checkValidDateString(str) {
        if (
            str === undefined ||
            str === 'unavailable' ||
            (typeof str !== 'string' && typeof str !== 'number')
        ) {
            const errorMessage =
                str === 'unavailable'
                    ? 'ha-time.status.unavailable'
                    : 'ha-time.status.invalid_property';
            throw new Error(this.RED._(errorMessage));
        }
    }

    // calculate offset if jsonata
    // then convert it to milliseconds
    getOffset() {
        let offset = this.nodeConfig.offset || '0';
        if (this.nodeConfig.offsetType === TYPEDINPUT_JSONATA) {
            try {
                offset = this.evaluateJSONata(offset);
            } catch (e) {
                this.node.error(
                    this.RED._('ha-time.errors.jsonata_error', {
                        message: e.message,
                    })
                );
                throw new Error('error');
            }
        }
        const offsetMs = getTimeInMilliseconds$1(
            offset,
            this.nodeConfig.offsetUnits
        );

        if (isNaN(offsetMs)) {
            this.node.error(
                this.RED._('ha-time.errors.offset_nan', { offset })
            );
            throw new Error(this.RED._('ha-time.status.error'));
        }

        return Number(offsetMs);
    }

    getRandomOffset(crontab, offset) {
        // if not repeating stay ahead of current time
        if (!this.nodeConfig.repeating && Math.sign(offset) === -1) {
            const cronTimestamp = crontab.getTime();
            const maxOffset =
                Math.max(Date.now(), cronTimestamp + offset) - cronTimestamp;
            return maxOffset * Math.random();
        }

        return offset * Math.random();
    }

    getPayloadValue(type, val) {
        let value = val;
        switch (type) {
            case TYPEDINPUT_BOOL:
                value = val === 'true';
                break;
            case TYPEDINPUT_DATE:
                value = Date.now();
                break;
            case TYPEDINPUT_JSONATA: {
                if (!val.length) {
                    value = '';
                    break;
                }
                try {
                    value = this.evaluateJSONata(val, {
                        entity: this.getEntity(),
                    });
                } catch (e) {
                    this.node.error(
                        this.RED._('ha-time.errors.invalid_jsonata_payload')
                    );
                    value = this.getEntity().state;
                }
                break;
            }
            case TYPEDINPUT_NUM:
            case TYPEDINPUT_STR:
            default:
                value = this.getCastValue(type, val);
                break;
        }
        return value;
    }

    getEntity() {
        return this.homeAssistant.getStates(this.nodeConfig.entityId);
    }
}

var Time_1 = Time$1;

/* eslint-disable camelcase */

const cloneDeep$2 = require$$0__default$6['default'];
const selectn$2 = require$$1__default$1['default'];

const EventsHaNode$1 = EventsHaNode_1;
const RenderTemplate$2 = mustacheContext;
const { shouldIncludeEvent: shouldIncludeEvent$1 } = utils;

const nodeOptions$3 = {
    debug: true,
    config: {
        entityid: {},
        entityidfiltertype: {},
        constraints: {},
        customoutputs: {},
        outputinitially: {},
        state_type: { value: 'str' },
    },
};

class TriggerState$1 extends EventsHaNode$1 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$3 });

        let eventTopic = 'ha_events:state_changed';

        if (this.nodeConfig.entityidfiltertype === 'exact') {
            eventTopic =
                this.eventTopic = `ha_events:state_changed:${this.nodeConfig.entityid}`;
        }

        this.addEventClientListener(
            eventTopic,
            this.onEntityStateChanged.bind(this)
        );

        this.NUM_DEFAULT_MESSAGES = 2;

        if (this.nodeConfig.outputinitially) {
            // Here for when the node is deploy without the server config being deployed
            if (this.isHomeAssistantRunning) {
                this.onDeploy();
            } else {
                this.addEventClientListener(
                    'ha_client:initial_connection_ready',
                    this.onStatesLoaded.bind(this)
                );
            }
        }
    }

    onInput({ message }) {
        if (message === 'enable' || message.payload === 'enable') {
            this.isEnabled = true;
            this.storage.saveData('isEnabled', true);
            this.updateHomeAssistant();
            return;
        }
        if (message === 'disable' || message.payload === 'disable') {
            this.isEnabled = false;
            this.storage.saveData('isEnabled', false);
            this.updateHomeAssistant();
            return;
        }

        const { entity_id, new_state, old_state } = message.payload;
        if (entity_id && new_state && old_state) {
            const evt = {
                event_type: 'state_changed',
                entity_id: entity_id,
                event: message.payload,
            };

            this.onEntityStateChanged(evt);
        }
    }

    onDeploy() {
        const entities = this.homeAssistant.getStates();
        this.onStatesLoaded(entities);
    }

    onStatesLoaded(entities) {
        for (const entityId in entities) {
            const eventMessage = {
                event_type: 'state_changed',
                entity_id: entityId,
                event: {
                    entity_id: entityId,
                    old_state: entities[entityId],
                    new_state: entities[entityId],
                },
            };

            this.onEntityStateChanged(eventMessage);
        }
    }

    onEntityStateChanged(evt) {
        if (this.isEnabled === false) {
            this.debugToClient(
                'incoming: node is currently disabled, ignoring received event'
            );
            return;
        }

        if (!selectn$2('event.new_state', evt) || !this.isHomeAssistantRunning) {
            return;
        }

        const eventMessage = cloneDeep$2(evt);

        if (
            !shouldIncludeEvent$1(
                eventMessage.entity_id,
                this.nodeConfig.entityid,
                this.nodeConfig.entityidfiltertype
            )
        ) {
            return;
        }

        // Convert and save original state if needed
        this.castState(
            eventMessage.event.old_state,
            this.nodeConfig.state_type
        );
        this.castState(
            eventMessage.event.new_state,
            this.nodeConfig.state_type
        );

        try {
            eventMessage.event.new_state.timeSinceChangedMs =
                Date.now() -
                new Date(eventMessage.event.new_state.last_changed).getTime();

            const constraintComparatorResults =
                this.getConstraintComparatorResults(
                    this.nodeConfig.constraints,
                    eventMessage
                );
            const statusText = `${eventMessage.event.new_state.state}${
                eventMessage.event_type === 'triggered' ? ' (triggered)' : ''
            }`;

            let outputs = this.getDefaultMessageOutputs(
                constraintComparatorResults,
                eventMessage
            );

            // If a constraint comparator failed we're done, also if no custom outputs to look at
            if (
                constraintComparatorResults.failed.length ||
                !this.nodeConfig.customoutputs.length
            ) {
                if (constraintComparatorResults.failed.length) {
                    this.status.setFailed(statusText);
                } else {
                    this.status.setSuccess(statusText);
                }
                this.debugToClient(
                    'done processing sending messages: ',
                    outputs
                );

                this.send(outputs);
                return;
            }

            const customOutputsComparatorResults =
                this.getCustomOutputsComparatorResults(
                    this.nodeConfig.customoutputs,
                    eventMessage
                );
            const customOutputMessages = customOutputsComparatorResults.map(
                (r) => r.message
            );

            outputs = outputs.concat(customOutputMessages);
            this.debugToClient('done processing sending messages: ', outputs);
            this.status.setSuccess(statusText);
            this.send(outputs);
        } catch (e) {
            this.node.error(e);
        }
    }

    getNodeEntityId() {
        return (
            this.nodeConfig.entityidfiltertype === 'exact' &&
            this.nodeConfig.entityid
        );
    }

    triggerNode(eventMessage) {
        this.onEntityStateChanged(eventMessage);
    }

    getConstraintComparatorResults(constraints, eventMessage) {
        const comparatorResults = [];

        // Check constraints
        for (const constraint of constraints) {
            const {
                comparatorType,
                comparatorValue,
                comparatorValueDatatype,
                propertyValue,
            } = constraint;
            const constraintTarget = this.getConstraintTargetData(
                constraint,
                eventMessage.event
            );

            const actualValue = selectn$2(
                constraint.propertyValue,
                constraintTarget.state
            );

            const comparatorResult = this.getComparatorResult(
                comparatorType,
                comparatorValue,
                actualValue,
                comparatorValueDatatype,
                {
                    entity: eventMessage.event.new_state,
                    prevEntity: eventMessage.event.old_state,
                }
            );

            if (comparatorResult === false) {
                this.debugToClient(
                    `constraint comparator: failed entity "${constraintTarget.entityid}" property "${propertyValue}" with value ${actualValue} failed "${comparatorType}" check against (${comparatorValueDatatype}) ${comparatorValue}`
                );
            }

            comparatorResults.push({
                constraint,
                constraintTarget,
                actualValue,
                comparatorResult,
            });
        }
        const failedComparators = comparatorResults.filter(
            (res) => !res.comparatorResult
        );
        return {
            all: comparatorResults || [],
            failed: failedComparators || [],
        };
    }

    getDefaultMessageOutputs(comparatorResults, eventMessage) {
        const { entity_id, event } = eventMessage;

        const msg = {
            topic: entity_id,
            payload: event.new_state.state,
            data: eventMessage,
        };
        let outputs;

        if (comparatorResults.failed.length) {
            this.debugToClient(
                'constraint comparator: one more more comparators failed to match constraints, message will send on the failed output'
            );

            msg.failedComparators = comparatorResults.failed;
            outputs = [null, msg];
        } else {
            outputs = [msg, null];
        }
        return outputs;
    }

    getCustomOutputsComparatorResults(outputs, eventMessage) {
        return outputs.reduce((acc, output) => {
            const result = {
                output,
                comparatorMatched: true,
                actualValue: null,
                message: null,
            };

            if (output.comparatorPropertyType !== 'always') {
                result.actualValue = selectn$2(
                    output.comparatorPropertyValue,
                    eventMessage.event
                );
                result.comparatorMatched = this.getComparatorResult(
                    output.comparatorType,
                    output.comparatorValue,
                    result.actualValue,
                    output.comparatorValueDataType,
                    {
                        entity: eventMessage.event.new_state,
                        prevEntity: eventMessage.event.old_state,
                    }
                );
            }
            result.message = this.getOutputMessage(result, eventMessage);
            acc.push(result);
            return acc;
        }, []);
    }

    getConstraintTargetData(constraint, triggerEvent) {
        const targetData = {
            entityid: null,
            state: null,
        };
        try {
            const isTargetThisEntity = constraint.targetType === 'this_entity';
            targetData.entityid = isTargetThisEntity
                ? this.nodeConfig.entityid
                : constraint.targetValue;

            targetData.state = isTargetThisEntity
                ? triggerEvent
                : this.homeAssistant.getStates(targetData.entityid);

            if (
                !isTargetThisEntity &&
                constraint.propertyType === 'current_state'
            ) {
                targetData.state = {
                    new_state: targetData.state,
                };
            }
        } catch (e) {
            this.node.debug(
                'Error during trigger:state comparator evaluation: ',
                e.stack
            );
            throw e;
        }

        return targetData;
    }

    getOutputMessage({ output, comparatorMatched, actualValue }, eventMessage) {
        // If comparator did not match
        if (!comparatorMatched) {
            this.debugToClient(
                `output comparator failed: property "${output.comparatorPropertyValue}" with value ${actualValue} failed "${output.comparatorType}" check against (${output.comparatorValueDataType}) ${output.comparatorValue}`
            );
            return null;
        }

        let payload = eventMessage.event.new_state.state;
        if (
            output.messageType === 'custom' ||
            output.messageType === 'payload'
        ) {
            // Render Template Variables
            payload = RenderTemplate$2(
                output.messageValue,
                eventMessage.event,
                this.node.context(),
                this.nodeConfig.server.name
            );

            switch (output.messageValueType) {
                case 'num':
                    payload = Number(payload);
                    break;
                case 'bool':
                    payload = payload === 'true';
                    break;
                case 'str':
                    break;
                case 'json':
                default:
                    try {
                        payload = JSON.parse(payload);
                    } catch (e) {}
                    break;
            }

            if (output.messageType === 'custom') {
                return payload;
            }
        }

        return {
            topic: eventMessage.entity_id,
            payload,
            data: eventMessage,
        };
    }
}

var TriggerState_1 = TriggerState$1;

const cloneDeep$1 = require$$0__default$6['default'];
const Joi = require$$0__default$3['default'];
const selectn$1 = require$$1__default$1['default'];

const EventsNode$1 = EventsNode_1;
const RenderTemplate$1 = mustacheContext;
const {
    shouldIncludeEvent,
    getWaitStatusText,
    getTimeInMilliseconds,
} = utils;

const nodeOptions$2 = {
    config: {
        name: {},
        server: {
            isNode: true,
        },
        outputs: 1,
        entityId: {},
        entityIdFilterType: {},
        property: {},
        comparator: {},
        value: {},
        valueType: {},
        timeout: {},
        timeoutType: {},
        timeoutUnits: {},
        entityLocation: {},
        entityLocationType: {},
        checkCurrentState: {},
        blockInputOverrides: {},
    },
    input: {
        entityId: {
            messageProp: ['payload.entity_id', 'payload.entityId'],
            configProp: 'entityId',
            validation: {
                haltOnFail: true,
                schema: Joi.alternatives()
                    .try(
                        Joi.array().items(Joi.string()),
                        Joi.string(),
                        Joi.object().instance(RegExp)
                    )
                    .label('entity_id'),
            },
        },
        entityIdFilterType: {
            messageProp: 'payload.entityIdFilterType',
            configProp: 'entityIdFilterType',
            default: 'exact',
            validation: {
                schema: Joi.string()
                    .valid('exact', 'regex', 'substring')
                    .label('entityIdFilterType'),
            },
        },
        property: {
            messageProp: 'payload.property',
            configProp: 'property',
            validation: {
                haltOnFail: true,
                schema: Joi.string().label('property'),
            },
        },
        comparator: {
            messageProp: 'payload.comparator',
            configProp: 'comparator',
            validation: {
                haltOnFail: true,
                schema: Joi.string()
                    .valid(
                        'is',
                        'is_not',
                        'lt',
                        'lte',
                        'gt',
                        'gte',
                        'includes',
                        'does_not_include',
                        'jsonata'
                    )
                    .label('comparator'),
            },
        },
        value: {
            messageProp: 'payload.value',
            configProp: 'value',
            validation: {
                schema: Joi.string().label('value'),
            },
        },
        valueType: {
            messageProp: 'payload.valueType',
            configProp: 'valueType',
            validation: {
                haltOnFail: true,
                schema: Joi.string().label('valueType'),
            },
        },
        timeout: {
            messageProp: 'payload.timeout',
            configProp: 'timeout',
        },
        timeoutUnits: {
            messageProp: 'payload.timeoutUnits',
            configProp: 'timeoutUnits',
            validation: {
                haltOnFail: true,
                schema: Joi.string()
                    .valid(
                        'milliseconds',
                        'seconds',
                        'minutes',
                        'hours',
                        'days'
                    )
                    .label('timeoutUnits'),
            },
        },
        entityLocation: {
            messageProp: 'payload.entityLocation',
            configProp: 'entityLocation',
            validation: {
                schema: Joi.string().label('entityLocation'),
            },
        },
        entityLocationType: {
            messageProp: 'payload.entityLocationType',
            configProp: 'entityLocationType',
            validation: {
                schema: Joi.string().label('entityLocationType'),
            },
        },
        checkCurrentState: {
            messageProp: 'payload.checkCurrentState',
            configProp: 'checkCurrentState',
            validation: {
                schema: Joi.boolean().label('checkCurrentState'),
            },
        },
    },
};

class WaitUntil$1 extends EventsNode$1 {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$2 });
        this.active = false;
        this.savedMessage = {};
        this.timeoutId = -1;
    }

    onEntityChange(evt) {
        const { event } = cloneDeep$1(evt);

        if (!this.active || !this.isHomeAssistantRunning) {
            return;
        }

        if (
            !shouldIncludeEvent(
                event.entity_id,
                this.savedConfig.entityId,
                this.savedConfig.entityIdFilterType
            )
        ) {
            return;
        }

        const result = this.getComparatorResult(
            this.savedConfig.comparator,
            this.savedConfig.value,
            selectn$1(this.savedConfig.property, event.new_state),
            this.savedConfig.valueType,
            {
                message: this.savedMessage,
                entity: event.new_state,
            }
        );

        if (!result) {
            return;
        }

        const { send, done } = this.savedConfig;
        clearTimeout(this.timeoutId);
        this.active = false;
        this.status.setSuccess('true');

        if (
            this.savedConfig.entityLocationType !== 'none' &&
            this.savedConfig.entityLocation
        ) {
            event.new_state.timeSinceChangedMs =
                Date.now() - new Date(event.new_state.last_changed).getTime();

            try {
                this.setContextValue(
                    event.new_state,
                    this.savedConfig.entityLocationType,
                    this.savedConfig.entityLocation,
                    this.savedMessage
                );
            } catch (e) {
                done(e, this.savedMessage);
            }
        }

        send([this.savedMessage, null]);
        done();
    }

    onInput({ message, parsedMessage, send, done }) {
        clearTimeout(this.timeoutId);

        if (Object.prototype.hasOwnProperty.call(message, 'reset')) {
            this.status.setText('reset');
            this.active = false;
            done();
            return;
        }

        const config = {
            entityId: parsedMessage.entityId.value,
            entityIdFilterType: parsedMessage.entityIdFilterType.value,
            property: parsedMessage.property.value,
            comparator: parsedMessage.comparator.value,
            value: parsedMessage.value.value,
            valueType: parsedMessage.valueType.value,
            timeout: parsedMessage.timeout.value,
            timeoutUnits: parsedMessage.timeoutUnits.value,
            entityLocation: parsedMessage.entityLocation.value,
            entityLocationType: parsedMessage.entityLocationType.value,
            checkCurrentState: parsedMessage.checkCurrentState.value,
        };

        // If blocking input overrides reset values to nodeConfig
        if (this.nodeConfig.blockInputOverrides === true) {
            Object.keys(config).forEach(
                (key) =>
                    (config[key] = (
                        key in this.nodeConfig ? this.nodeConfig : config
                    )[key])
            );
        }

        // Render mustache templates in the entity id field
        if (
            parsedMessage.entityId.source === 'config' &&
            config.entityIdFilterType === 'exact'
        ) {
            config.entityId = RenderTemplate$1(
                parsedMessage.entityId.value,
                message,
                this.node.context(),
                this.nodeConfig.server.name
            );
        }

        // If the timeout field is jsonata type evaluate the expression and
        // it to timeout
        let timeout = config.timeout;
        if (
            parsedMessage.timeout.source === 'config' &&
            this.nodeConfig.timeoutType === 'jsonata'
        ) {
            try {
                timeout = this.evaluateJSONata(timeout, { message });
            } catch (e) {
                this.status.setFailed('Error');
                done(`JSONata Error: ${e.message}`);
                return;
            }
            config.timeout = timeout;
        }

        // Validate if timeout is a number >= 0
        if (isNaN(timeout) || timeout < 0) {
            this.status.setFailed('Error');
            done(`Invalid value for 'timeout': ${timeout}`);
            return;
        }

        this.removeEventClientListeners();
        let eventTopic = 'ha_events:state_changed';

        if (config.entityIdFilterType === 'exact') {
            eventTopic = `${eventTopic}:${config.entityId}`;
        }

        this.addEventClientListener(eventTopic, this.onEntityChange.bind(this));

        this.savedMessage = message;
        this.active = true;
        let statusText = 'waiting';

        if (timeout > 0) {
            statusText = getWaitStatusText(timeout, config.timeoutUnits);
            timeout = getTimeInMilliseconds(timeout, config.timeoutUnits);

            this.timeoutId = setTimeout(() => {
                const state = Object.assign(
                    {},
                    this.homeAssistant.getStates(config.entityId)
                );

                state.timeSinceChangedMs =
                    Date.now() - new Date(state.last_changed).getTime();

                this.setContextValue(
                    state,
                    config.entityLocationType,
                    config.entityLocation,
                    message
                );

                this.active = false;
                this.status.setFailed('timed out');
                send([null, message]);
                done();
            }, timeout);
        }
        this.status.setText(statusText);
        this.savedConfig = config;
        this.savedConfig.send = send;
        this.savedConfig.done = done;

        // Only check current state when filter type is exact
        if (
            config.checkCurrentState === true &&
            config.entityIdFilterType === 'exact'
        ) {
            const currentState = this.homeAssistant.getStates(config.entityId);

            this.onEntityChange({
                event: {
                    entity_id: config.entityId,
                    new_state: currentState,
                },
            });
        }
    }
}

var WaitUntil_1 = WaitUntil$1;

const EventsNode = EventsNode_1;

const { INTEGRATION_UNLOADED } = _const;

const nodeOptions$1 = {
    config: {
        name: {},
        server: { isNode: true },
        outputs: 1,
        webhookId: {},
        exposeToHomeAssistant: () => true,
        outputProperties: {},
    },
};

class Webhook$1 extends EventsNode {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions: nodeOptions$1 });

        if (this.isIntegrationLoaded) {
            this.registerEntity();
        }
    }

    onHaEventsClose() {
        super.onHaEventsClose();

        this.removeWebhook = null;
    }

    onEvent(evt) {
        const message = {};
        try {
            this.setCustomOutputs(this.nodeConfig.outputProperties, message, {
                config: this.nodeConfig,
                data: evt.data.payload,
                headers: evt.data.headers,
                params: evt.data.params,
            });
        } catch (e) {
            this.node.error(e);
            this.status.setFailed('error');
            return;
        }

        this.status.setSuccess('Received');
        this.send(message);
    }

    onHaIntegration(type) {
        super.onHaIntegration(type);

        if (type === INTEGRATION_UNLOADED) {
            if (this.removeWebhook) {
                this.removeWebhook();
                this.removeWebhook = null;
            }
            this.node.error(
                'Node-RED custom integration has been removed from Home Assistant it is needed for this node to function.'
            );
            this.status.setFailed('Error');
        }
    }

    async registerEntity() {
        if (super.registerEntity() === false) {
            return;
        }

        if (!this.nodeConfig.webhookId) {
            this.node.error(this.integrationErrorMessage);
            this.status.setFailed('Error');
            return;
        }

        if (!this.removeWebhook) {
            this.node.debug(`Adding webhook to HA`);
            this.removeWebhook = await this.homeAssistant.subscribeMessage(
                this.onEvent.bind(this),
                {
                    type: 'nodered/webhook',
                    webhook_id: this.nodeConfig.webhookId,
                    name: this.node.id,
                    server_id: this.nodeConfig.server.id,
                },
                { resubscribe: false }
            );
        }
        this.status.setSuccess('Registered');
        this.registered = true;
    }

    onClose(removed) {
        super.onClose(removed);

        if (this.registered && this.isConnected && this.removeWebhook) {
            this.node.debug('Removing webhook from HA');
            this.removeWebhook().catch(() => {});
        }
    }
}

var Webhook_1 = Webhook$1;

const cloneDeep = require$$0__default$6['default'];

const EventsHaNode = EventsHaNode_1;
const { getLocationData, getZoneData, inZone } = utils;
const { ZONE_ENTER, ZONE_LEAVE, ZONE_ENTER_OR_LEAVE } = _const;

const nodeOptions = {
    config: {
        entities: {},
        event: {},
        zones: {},
    },
};

class Zone$1 extends EventsHaNode {
    constructor({ node, config, RED, status }) {
        super({ node, config, RED, status, nodeOptions });

        for (const entity of this.nodeConfig.entities) {
            this.addEventClientListener(
                `ha_events:state_changed:${entity}`,
                this.onStateChanged.bind(this)
            );
        }
    }

    onStateChanged(evt) {
        if (this.isEnabled === false || !this.isHomeAssistantRunning) {
            return;
        }
        const { entity_id: entityId, event } = cloneDeep(evt);

        const zones = this.getValidZones(event.old_state, event.new_state);

        if (!zones.length) {
            this.status.setFailed(entityId);
            return;
        }

        event.new_state.timeSinceChangedMs =
            Date.now() - new Date(event.new_state.last_changed).getTime();

        const msg = {
            topic: entityId,
            payload: event.new_state.state,
            data: event,
            zones,
        };
        const statusMessage = `${entityId} ${this.nodeConfig.event} ${zones
            .map((z) => z.entity_id)
            .join(',')}`;
        this.status.setSuccess(statusMessage);
        this.send(msg);
    }

    getValidZones(fromState, toState) {
        const config = this.nodeConfig;
        const fromLocationData = getLocationData(fromState);
        const toLocationData = getLocationData(toState);
        if (!fromLocationData || !toLocationData) return [];
        const zones = this.getZones();
        const validZones = zones.filter((zone) => {
            const zoneData = getZoneData(zone);
            if (!zoneData) return false;
            const fromMatch = inZone(fromLocationData, zoneData);
            const toMatch = inZone(toLocationData, zoneData);

            return (
                (config.event === ZONE_ENTER && !fromMatch && toMatch) ||
                (config.event === ZONE_LEAVE && fromMatch && !toMatch) ||
                (config.event === ZONE_ENTER_OR_LEAVE && fromMatch !== toMatch)
            );
        });

        return validZones;
    }

    getZones() {
        const node = this;
        const entities = this.homeAssistant.getStates();
        const zones = [];
        for (const entityId in entities) {
            if (node.nodeConfig.zones.includes(entityId)) {
                zones.push(entities[entityId]);
            }
        }

        return zones;
    }

    // Do nothing for zone node
    handleTriggerMessage() {}
}

var Zone_1 = Zone$1;

const bonjour = require$$0__default$b['default']();
const flatten = require$$1__default$7['default'];
const selectn = require$$1__default$1['default'];

let getNode;
let errorMessage;

function disableCache(req, res, next) {
    const node = getNode(req.params.id);

    if (selectn('config.cacheJson', node) === false) {
        res.setHeader('Surrogate-Control', 'no-store');
        res.setHeader(
            'Cache-Control',
            'no-store, no-cache, must-revalidate, proxy-revalidate'
        );
        res.setHeader('Pragma', 'no-cache');
        res.setHeader('Expires', '0');
    }

    next();
}

function setHomeAssistant(req, res, next) {
    const homeAssistant = getHomeAssistant(req.params.serverId);
    if (!homeAssistant) {
        return res.status(503).send({ error: errorMessage });
    }

    req.homeAssistant = homeAssistant;
    next();
}

async function getDeviceActions(req, res) {
    const deviceId = req.query.deviceId;
    const actions = await req.homeAssistant.getDeviceActions(deviceId);
    res.json(actions);
}

async function getDeviceActionCapabilities(req, res) {
    const action = req.query.action;
    const capabilities = await req.homeAssistant.getDeviceActionCapabilities(
        action
    );
    res.json(capabilities);
}

async function getDeviceTriggers(req, res) {
    const deviceId = req.query.deviceId;
    const triggers = await req.homeAssistant.getDeviceTriggers(deviceId);
    res.json(triggers);
}

async function getDeviceTriggerCapabilities(req, res) {
    const trigger = req.query.trigger;
    const capabilities = await req.homeAssistant.getDeviceTriggerCapabilities(
        trigger
    );
    res.json(capabilities);
}

function getEntities$2(req, res) {
    const states = req.homeAssistant.getEntities();
    res.json(states);
}

function getStates(req, res) {
    const entityId = req.query.entityId;
    const states = req.homeAssistant.getStates(entityId);
    res.json(states);
}

function getServices(req, res) {
    const services = req.homeAssistant.getServices();
    res.json(services);
}

function getProperties(req, res) {
    let flat = [];
    let singleEntity = !!req.query.entityId;

    let states = req.homeAssistant.getStates(req.query.entityId);

    if (!states) {
        states = req.homeAssistant.getStates();
        singleEntity = false;
    }

    if (singleEntity) {
        flat = Object.keys(flatten(states)).filter(
            (e) => e.indexOf(req.query.term) !== -1
        );
    } else {
        flat = Object.values(states).map((entity) =>
            Object.keys(flatten(entity))
        );
    }
    const uniqProperties = [...new Set([].concat(...flat))];
    const sortedProperties = uniqProperties.sort((a, b) => {
        if (!a.includes('.') && b.includes('.')) return -1;
        if (a.includes('.') && !b.includes('.')) return 1;
        if (a < b) return -1;
        if (a > b) return 1;

        return 0;
    });

    res.json(sortedProperties);
}

async function getTags(req, res) {
    if (req.query.update) {
        await req.homeAssistant.updateTags();
    }

    const tags = req.homeAssistant.getTags().map((t) => {
        return {
            id: t.tag_id,
            name: t.name,
        };
    });

    res.json(tags);
}

async function getTranslations(req, res) {
    const category = req.query.cat;
    const language = req.query.lang;
    const devices = await req.homeAssistant.getTranslations(category, language);
    res.json(devices.resources);
}

function getIntegrationVersion(req, res) {
    const client = req.homeAssistant;
    const data = { version: client ? client.integrationVersion : 0 };

    res.json(data);
}

function getHomeAssistant(nodeId) {
    const node = getNode(nodeId);
    return selectn('controller.homeAssistant', node);
}

function findServers(req, res) {
    const instances = [];
    const browser = bonjour.find({ type: 'home-assistant' }, (service) => {
        instances.push({
            label: service.name
                ? `${service.name} (${service.txt.base_url})`
                : service.txt.base_url,
            value: service.txt.base_url,
        });
    });

    // Add a bit of delay for all services to be discovered
    setTimeout(() => {
        res.json(instances);
        browser.stop();
    }, 3000);
}

function createRoutes$1(RED) {
    getNode = RED.nodes.getNode;
    errorMessage = RED._('config-server.errors.no_server_selected');

    const endpoints = {
        deviceActions: getDeviceActions,
        deviceActionCapabilities: getDeviceActionCapabilities,
        deviceTriggers: getDeviceTriggers,
        deviceTriggerCapabilities: getDeviceTriggerCapabilities,
        entities: getEntities$2,
        properties: getProperties,
        services: getServices,
        states: getStates,
        tags: getTags,
        translations: getTranslations,
    };
    Object.entries(endpoints).forEach(([key, value]) =>
        RED.httpAdmin.get(
            `/homeassistant/${key}/:serverId?`,
            RED.auth.needsPermission('server.read'),
            disableCache.bind(this),
            setHomeAssistant,
            value.bind(this)
        )
    );

    RED.httpAdmin.get(
        `/homeassistant/version/:serverId`,
        RED.auth.needsPermission('server.read'),
        setHomeAssistant,
        getIntegrationVersion
    );

    RED.httpAdmin.get('/homeassistant/discover', findServers);
}

var routes = {
    createRoutes: createRoutes$1,
};

const migrations$j = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                outputProperties: [],
                location: undefined,
                locationType: undefined,
            };

            if (schema.locationType !== 'none') {
                newSchema.outputProperties = [
                    {
                        property: schema.location,
                        propertyType: schema.locationType,
                        value: '',
                        valueType: 'results',
                    },
                ];
            }

            return newSchema;
        },
    },
];

var api$1 = migrations$j;

const migrations$i = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        // entity_id moved from the data property to its on property
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
            };
            try {
                const data = JSON.parse(schema.data);
                if (data.entity_id) {
                    newSchema.entityId = data.entity_id;
                    delete data.entity_id;
                    newSchema.data = !Object.keys(data).length
                        ? ''
                        : JSON.stringify(data);
                } else {
                    newSchema.entityId = '';
                }
            } catch (e) {}

            return newSchema;
        },
    },
    {
        version: 2,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 2,
                outputProperties: [],
            };

            if (schema.output_location_type !== 'none') {
                newSchema.outputProperties = [
                    {
                        property: schema.output_location,
                        propertyType: schema.output_location_type,
                        value: '',
                        valueType: 'data',
                    },
                ];
            }

            return newSchema;
        },
    },
    {
        version: 3,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 3,
                queue: 'none',
            };

            return newSchema;
        },
    },
];

var callService$1 = migrations$i;

const migrations$h = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                ha_boolean: schema.ha_boolean || 'y|yes|true|on|home|open',
                rejectUnauthorizedCerts:
                    schema.rejectUnauthorizedCerts !== undefined
                        ? schema.rejectUnauthorizedCerts
                        : true,
                connectionDelay:
                    schema.connectionDelay !== undefined
                        ? schema.connectionDelay
                        : true,
                cacheJson:
                    schema.cacheJson !== undefined ? schema.cacheJson : true,
            };
            return newSchema;
        },
    },
];

var configServer$1 = migrations$h;

const migrations$g = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };

            return newSchema;
        },
    },
    {
        // CHANGES:
        // * if state changed to send true condition to the first out and false to the second
        // * typedInputs state_location and entity_location
        // * set defaults for new fields
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                blockInputOverrides: false,
                entity_location: 'data',
                halt_if_compare: 'is',
                override_payload:
                    schema.override_payload === false ? 'none' : 'msg',
                override_data: schema.override_data === false ? 'none' : 'msg',
                state_location: 'payload',
                state_type: 'str',
            };
            return newSchema;
        },
    },
    {
        version: 2,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 2,
                outputProperties: [],
                state_location: undefined,
                override_payload: undefined,
                entity_location: undefined,
                override_data: undefined,
                override_topic: undefined,
            };

            if (schema.override_payload !== 'none') {
                newSchema.outputProperties.push({
                    property: schema.state_location,
                    propertyType: schema.override_payload,
                    value: '',
                    valueType: 'entityState',
                });
            }
            if (schema.override_data !== 'none') {
                newSchema.outputProperties.push({
                    property: schema.entity_location,
                    propertyType: schema.override_data,
                    value: '',
                    valueType: 'entity',
                });
            }
            if (schema.override_topic === true) {
                newSchema.outputProperties.push({
                    property: 'topic',
                    propertyType: 'msg',
                    value: '',
                    valueType: 'triggerId',
                });
            }
            return newSchema;
        },
    },
];

var currentState$1 = migrations$g;

const migrations$f = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var device$1 = migrations$f;

const migrations$e = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                inputOverride: 'allow',
            };

            return newSchema;
        },
    },
];

var entity$1 = migrations$e;

const migrations$d = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
                waitForRunning:
                    schema.waitForRunning !== undefined
                        ? schema.waitForRunning
                        : true,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                outputProperties: [
                    {
                        property: 'payload',
                        propertyType: 'msg',
                        value: '',
                        valueType: 'eventData',
                    },
                    {
                        property: 'topic',
                        propertyType: 'msg',
                        value: '$outputData("eventData").event_type',
                        valueType: 'jsonata',
                    },
                    {
                        property: 'event_type',
                        propertyType: 'msg',
                        value: '$outputData("eventData").event_type',
                        valueType: 'jsonata',
                    },
                ],
            };
            return newSchema;
        },
    },
];

var eventsAll$1 = migrations$d;

const migrations$c = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
                state_type:
                    schema.state_type !== undefined ? schema.state_type : 'str',
                halt_if_type:
                    schema.halt_if_type !== undefined
                        ? schema.halt_if_type
                        : 'str',
                halt_if_compare:
                    schema.halt_if_compare !== undefined
                        ? schema.halt_if_compare
                        : 'is',
            };

            return newSchema;
        },
    },
    {
        // CHANGES:
        // - if state changed to send true condition to the first out and false to the second
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                ignorePrevStateNull: false,
                ignorePrevStateUnknown: false,
                ignorePrevStateUnavailable: false,
                ignoreCurrentStateUnknown: false,
                ignoreCurrentStateUnavailable: false,
            };

            return newSchema;
        },
    },
    {
        version: 2,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 2,
                for: schema.for !== undefined ? schema.for : '0',
                forType: schema.forType || 'num',
                forUnits: schema.forUnits || 'minutes',
            };

            return newSchema;
        },
    },
    {
        version: 3,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 3,
                outputProperties: [
                    {
                        property: 'payload',
                        propertyType: 'msg',
                        value: '',
                        valueType: 'entityState',
                    },
                    {
                        property: 'data',
                        propertyType: 'msg',
                        value: '',
                        valueType: 'eventData',
                    },
                    {
                        property: 'topic',
                        propertyType: 'msg',
                        value: '',
                        valueType: 'triggerId',
                    },
                ],
            };

            return newSchema;
        },
    },
];

var eventsState$1 = migrations$c;

const migrations$b = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var fireEvent$1 = migrations$b;

const migrations$a = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var getEntities$1 = migrations$a;

const migrations$9 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
                output_type:
                    schema.output_type === undefined
                        ? 'array'
                        : schema.output_type,
            };
            if (newSchema.output_location === undefined) {
                newSchema.output_location = 'payload';
                newSchema.output_location_type = 'msg';
            }
            return newSchema;
        },
    },
];

var getHistory$1 = migrations$9;

const migrations$8 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                state_type: 'str',
                halt_if_type: 'str',
                halt_if_compare: 'is',
                updateIntervalUnits: 'seconds',
            };
            return newSchema;
        },
    },
];

var pollState$1 = migrations$8;

const migrations$7 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            if (newSchema.templateLocationType === undefined) {
                newSchema.templateLocation = 'template';
                newSchema.templateLocationType = 'msg';
            }
            if (newSchema.resultsLocationType === undefined) {
                newSchema.resultsLocation = 'payload';
                newSchema.resultsLocationType = 'msg';
            }
            return newSchema;
        },
    },
];

var renderTemplate$1 = migrations$7;

const migrations$6 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var tag$1 = migrations$6;

const migrations$5 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var time$1 = migrations$5;

const migrations$4 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var triggerState$1 = migrations$4;

const migrations$3 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
                entityIdFilterType: schema.entityIdFilterType || 'exact',
                timeoutType: schema.timeoutType || 'num',
            };

            if (newSchema.blockInputOverrides === undefined) {
                newSchema.blockInputOverrides = true;
            }
            if (newSchema.checkCurrentState === undefined) {
                newSchema.checkCurrentState = false;
            }
            return newSchema;
        },
    },
];

var waitUntil$1 = migrations$3;

const migrations$2 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
    {
        version: 1,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 1,
                outputProperties: [
                    {
                        property: 'topic',
                        propertyType: 'msg',
                        value: '',
                        valueType: 'triggerId',
                    },
                ],
                payloadLocation: undefined,
                payloadLocationType: undefined,
                headersLocation: undefined,
                headersLocationType: undefined,
            };

            if (schema.payloadLocationType !== 'none') {
                newSchema.outputProperties.push({
                    property: schema.payloadLocation,
                    propertyType: schema.payloadLocationType,
                    value: '',
                    valueType: 'data',
                });
            }
            if (schema.headersLocationType !== 'none') {
                newSchema.outputProperties.push({
                    property: schema.headersLocation,
                    propertyType: schema.headersLocationType,
                    value: '',
                    valueType: 'headers',
                });
            }
            return newSchema;
        },
    },
];

var webhook$1 = migrations$2;

const migrations$1 = [
    {
        version: 0,
        up: (schema) => {
            const newSchema = {
                ...schema,
                version: 0,
            };
            return newSchema;
        },
    },
];

var zone$1 = migrations$1;

const api = api$1;
const callService = callService$1;
const configServer = configServer$1;
const currentState = currentState$1;
const device = device$1;
const entity = entity$1;
const eventsAll = eventsAll$1;
const eventsState = eventsState$1;
const fireEvent = fireEvent$1;
const getEntities = getEntities$1;
const getHistory = getHistory$1;
const pollState = pollState$1;
const renderTemplate = renderTemplate$1;
const tag = tag$1;
const time = time$1;
const triggerState = triggerState$1;
const waitUntil = waitUntil$1;
const webhook = webhook$1;
const zone = zone$1;

const nodeTypeTranslation = {
    'ha-api': api,
    'api-call-service': callService,
    server: configServer,
    'api-current-state': currentState,
    'ha-device': device,
    'ha-entity': entity,
    'server-events': eventsAll,
    'server-state-changed': eventsState,
    'ha-fire-event': fireEvent,
    'ha-get-entities': getEntities,
    'api-get-history': getHistory,
    'poll-state': pollState,
    'api-render-template': renderTemplate,
    'trigger-state': triggerState,
    'ha-tag': tag,
    'ha-time': time,
    'ha-wait-until': waitUntil,
    'ha-webhook': webhook,
    'ha-zone': zone,
};

function migrate$2(schema) {
    const currentVersion = getCurrentVersion$2(schema.type);
    if (schema.version !== undefined && schema.version >= currentVersion) {
        return schema;
    }

    const currentMigration = findMigration(schema.type, schema.version).up;
    const newSchema = currentMigration(schema);

    return migrate$2(newSchema);
}

function findMigration(nodeType, version = -1) {
    const migrations = getMigrationsByType(nodeType);
    const migration = migrations.find((m) => m.version === Number(version) + 1);

    return migration;
}

function getMigrationsByType(nodeType) {
    return nodeTypeTranslation[nodeType];
}

function getCurrentVersion$2(nodeType) {
    const migrations = getMigrationsByType(nodeType) || [];
    const currentVersion = migrations.reduce((acc, i) => {
        return i.version > acc ? i.version : acc;
    }, 0);

    return currentVersion;
}

var migrate_1 = {
    getCurrentVersion: getCurrentVersion$2,
    migrate: migrate$2,
};

const { migrate: migrate$1, getCurrentVersion: getCurrentVersion$1 } = migrate_1;

var migrations = {
    getCurrentVersion: getCurrentVersion$1,
    migrate: migrate$1,
};

const { getCurrentVersion } = migrations;
const { toCamelCase } = utils;

function getExposedSettings$1(type) {
    const name = toCamelCase(type).replace(/-/g, '');

    const expose = {
        settings: {
            [`${name}Version`]: {
                value: getCurrentVersion(type),
                exportable: true,
            },
        },
    };

    if (type === 'server') {
        expose.credentials = {
            host: { type: 'text' },
            access_token: { type: 'text' },
        };
    }

    return expose;
}

var exposedSettings = {
    getExposedSettings: getExposedSettings$1,
};

const Api = Api_1;
const CallService = CallService_1;
const ConfigServer = ConfigServer_1;
const CurrentState = CurrentState_1;
const DeviceAction = DeviceAction_1;
const DeviceTrigger = DeviceTrigger_1;
const EventsAll = EventsAll_1;
const EventsState = EventsState_1;
const FireEvent = FireEvent_1;
const GetEntities = GetEntities_1;
const GetHistory = GetHistory_1;
const PollState = PollState_1;
const RenderTemplate = RenderTemplate_1;
const Sensor = Sensor_1;
const Switch = Switch_1;
const Tag = Tag_1;
const Time = Time_1;
const TriggerState = TriggerState_1;
const WaitUntil = WaitUntil_1;
const Webhook = Webhook_1;
const Zone = Zone_1;
const {
    Status,
    EventsStatus,
    SwitchEntityStatus,
} = status;
const { createRoutes } = routes;
const { getExposedSettings } = exposedSettings;
const { migrate } = migrations;

var src = function (RED) {
    createRoutes(RED);

    function apiNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new Api({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function callServiceNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new CallService({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function configServerNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        this.controller = new ConfigServer({
            node: this,
            config: this.config,
            RED,
        });
        this.controller.init();
    }

    function currentStateNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new CurrentState({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function deviceNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const params = {
            node: this,
            config: this.config,
            RED,
        };
        switch (config.deviceType) {
            case 'action': {
                const status = new Status(this);
                this.controller = new DeviceAction({ ...params, status });
                break;
            }
            case 'trigger': {
                const status = new EventsStatus(this);
                this.controller = new DeviceTrigger({ ...params, status });
                break;
            }
            default:
                this.status({ text: 'Error' });
                throw new Error(`Invalid entity type: ${config.deviceType}`);
        }
    }

    function entityNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);

        switch (config.entityType) {
            case 'binary_sensor':
            case 'sensor': {
                const status = new Status(this);
                this.controller = new Sensor({
                    node: this,
                    config: this.config,
                    RED,
                    status,
                });

                break;
            }
            case 'switch': {
                const status = new SwitchEntityStatus(this);
                this.controller = new Switch({
                    node: this,
                    config: this.config,
                    RED,
                    status,
                });
                break;
            }
            default:
                this({ text: 'Error' });
                throw new Error(`Invalid entity type: ${config.entityType}`);
        }
    }

    function eventsAllNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new EventsAll({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function eventsStateNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new EventsState({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function fireEventNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new FireEvent({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function getEntitiesNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new GetEntities({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function getHistoryNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new GetHistory({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function pollStateNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new PollState({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function renderTemplateNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new RenderTemplate({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function tagNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new Tag({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function timeNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new Time({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function triggerStateNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new TriggerState({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function waitUntilNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new Status(this);
        this.controller = new WaitUntil({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function webhookNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new Webhook({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    function zoneNode(config) {
        RED.nodes.createNode(this, config);

        this.config = migrate(config);
        const status = new EventsStatus(this);
        this.controller = new Zone({
            node: this,
            config: this.config,
            RED,
            status,
        });
    }

    const nodes = {
        'ha-api': apiNode,
        'api-call-service': callServiceNode,
        server: configServerNode,
        'api-current-state': currentStateNode,
        'ha-device': deviceNode,
        'ha-entity': entityNode,
        'server-events': eventsAllNode,
        'server-state-changed': eventsStateNode,
        'ha-fire-event': fireEventNode,
        'ha-get-entities': getEntitiesNode,
        'api-get-history': getHistoryNode,
        'poll-state': pollStateNode,
        'api-render-template': renderTemplateNode,
        'trigger-state': triggerStateNode,
        'ha-tag': tagNode,
        'ha-time': timeNode,
        'ha-wait-until': waitUntilNode,
        'ha-webhook': webhookNode,
        'ha-zone': zoneNode,
    };

    for (const type in nodes) {
        RED.nodes.registerType(type, nodes[type], getExposedSettings(type));
    }
};

module.exports = src;
